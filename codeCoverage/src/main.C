#include <stdio.h>
#include <iostream.h>
#include <stdlib.h>

#ifdef sparc_sun_solaris2_4

#include <string.h>
#include <fstream.h>
#include <limits.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

#endif

#ifdef sparc_sun_solaris2_4

#include <CCcommon.h>
#include <CCPreInstrument.h>
#include <CCOnDemandInstrument.h>

#endif

/** function to show the usage of code coverage tool 
  * one usage is to run and produce the coverage results
  * in a binary file and the other is to view the coverage results
  */
void printUsage(char* s,bool d=false){
	cerr << "Usage_1 : " << s << " [--deletion <interval>] [--dominator] \\" << endl
	     << "                 [--ondemand] [--suffix <outfile suffix>] \\" << endl
	     << "                 --run <executable> <arguments>" << endl;
	cerr << "Usage_2 : " << s << " --view <fileName>" << endl;

	if(d)
 	  cerr 
	     << endl
	     << "Information : " << endl
	     << endl
	     << "--deletion     : Interval to delete instrumentation code in seconds." << endl
	     << "                 Default value is 0, that is no deletion of " << endl
	     << "                 instrumentation code." << endl
	     << "--dominator    : Flag to make this tool use dominator information." << endl
	     << "                 All basic blocks is used by default." << endl
	     << "--suffix       : The suffix of the output file, generated by appending" << endl
	     << "                 to the name of executable.Output file contains " << endl
	     << "                 coverage information" << endl
	     << "--ondemand     : Flag to instrument functions when called first time." << endl
	     << "                 By default, the functions with source line information" << endl
	     << "                 is pre-instrumented." << endl
	     << "--run          : The executable and its arguments to run is given after" << endl
	     << "                 this flag. This flag HAS to come after all other flags" << endl
	     << "--view         : To view the output file generated from coverage data" << endl
	     << "                 in text format. The output file is generated if it is" << endl
	     << "                 executed in Usage_1 format." << endl
	     << endl << endl;

	exit(0);
}

/** main function */
int main(int argc,char* argv[]){
#ifdef sparc_sun_solaris2_4

	bool useDominator = false;
	bool useOnDemand = false;
	char* suffix = ".dyncov";
	int interval = 0;
	int execIndex = 0;
	char* p = NULL;

	if(argc < 3)
		printUsage(argv[0],true);

	if((argc == 3) && !strncmp("--view",argv[1],6))
		return CodeCoverage::viewCodeCoverageInfo(argv[2]);

	for(int i=1;i<argc;i++){
		if(!strncmp("--del",argv[i],5)){
			i++;
			if(!strncmp("--",argv[i],2))
				printUsage(argv[0]);
			interval = strtol(argv[i],&p,10);
			if(argv[i] == p)
				printUsage(argv[0]);
		}
		else if(!strncmp("--dom",argv[i],5))
			useDominator = true;
		else if(!strncmp("--ond",argv[i],5))
			useOnDemand = true;
		else if(!strncmp("--run",argv[i],5)){
			execIndex = i+1;
			break;
		}
		else if(!strncmp("--suf",argv[i],5)){
			i++;
			if(!strncmp("--",argv[i],2))
                                printUsage(argv[0]);
			suffix = argv[i];
		}
		else
			printUsage(argv[0]);
	}

	if(!execIndex || (execIndex == argc))
		 printUsage(argv[0]);

        struct stat statBuffer;
        if(stat(argv[execIndex],&statBuffer) < 0){
		cerr << "ERROR : Executable " << argv[execIndex] 
		     << " does not exist" << endl;
		exit(-100);
	}

	CodeCoverage* codeCoverage = NULL;

	/** create the corresponding code coverage object */
	if(useOnDemand)
		codeCoverage = new CCOnDemandInstrument;
	else
		codeCoverage = new CCPreInstrument;

	int errorCode = Error_OK;

	/** initialize the necessary BPatch obejcts */
	errorCode = codeCoverage->initialize(argv+execIndex,interval,
					     useDominator,suffix);
	if(errorCode < Error_OK){
		codeCoverage->terminate();
		exit(errorCode);
	}

	/** select functions whose source code line information
	  * is available in the executable 
	  */
	errorCode = codeCoverage->selectFunctions();
	if(errorCode < Error_OK){
		codeCoverage->terminate();
		exit(errorCode);
	}
	
	/** instrument a breakpoint to the beginning of the exit handle
	  * to catch the termination of the mutatee 
	  */
	errorCode = codeCoverage->instrumentExitHandle();
	if(errorCode < Error_OK){
		codeCoverage->terminate();
		exit(errorCode);
	}

	/** insert the initial instrumentation code for the functions
	  * that are selected to be instrumented for code coverage 
	  */
	errorCode = codeCoverage->instrumentInitial();
	if(errorCode < Error_OK){
		codeCoverage->terminate();
		exit(errorCode);
	}

	/** runs the mutatee after the instrumentation */
	errorCode = codeCoverage->run();
	if(errorCode < Error_OK){
		codeCoverage->terminate();
		exit(errorCode);
	}

	return Error_OK;
#else
	cerr << endl
	     << "IMPORTANT Information : " << endl
	     << "\tCodeCoverage Tool is not implemented for" << endl
	     << "\tthis platform...." << endl << endl << endl;

	printUsage(argv[0],true);

	return 0;
#endif
}
