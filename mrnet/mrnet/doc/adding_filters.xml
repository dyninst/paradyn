<chapter id="adding_filters"><title>Adding New Filters</title>

<sect1><title>Defining an MRNet Filter</title>

<para>
A filter function has the following signature
<funcsynopsis>
<funcprototype>
  <funcdef>void <function>filter_name</function></funcdef>
    <paramdef>std::vector&lt; PacketPtr &gt; &amp; <parameter>packets_in</parameter></paramdef>
    <paramdef>std::vector&lt; PacketPtr &gt; &amp; <parameter>packets_out</parameter></paramdef>
    <paramdef>std::vector&lt; PacketPtr &gt; &amp; <parameter>packets_out_reverse</parameter></paramdef>
    <paramdef>void ** <parameter>local_storage</parameter></paramdef>
    <paramdef>PacketPtr &amp; <parameter>config_params</parameter></paramdef>
</funcprototype>
</funcsynopsis>
<varname>packets_in</varname> is a reference to a vector of Packets serving
as input to the filter function. <varname>packets_out</varname> is a
reference to a vector into which output Packets should be placed. In the
rare case where Packets need to be sent in the reverse direction on the
Stream, <varname>packets_out_reverse</varname> should be used instead of 
<varname>packets_out</varname>.
<varname>local_storage</varname> may be used to define and maintain
state specific to a filter instance. Finally, <varname>config_params</varname>
is a reference to a PacketPtr containing the current configuration settings
for the filter instance, as can be set using <function>Stream::set_FilterParameters</function>. 
</para>

<para>
For each filter function defined in a shared object file, there must be a
<type>const char *</type> symbol named
by the string formed by the concatenation of the filter function name and
the suffix "_format_string". For instance, if the filter function is named
<varname>my_filter_func</varname>, the shared object must define a symbol
<type>const char *</type><varname>my_filter_func_format_string</varname>.
The value of this string will be the MRNet format string describing the
format of data that the filter can operate on. A value of <literal>""</literal>
 denotes that the filter can operate on data of arbitrary value.
</para>
</sect1>

<sect1><title>Creating and Using MRNet Filter Shared Object Files</title>
<para>
This topic currently pertains to use with the GNU C++ compiler only.
</para>

<para>
Since we use the C facility <function>dlopen()</function> to dynamically
load new filter functions, all C++ symbols must be exported. That is, 
the symbol definitions must fall with the statements

<programlisting>
extern "C" {
</programlisting>
and 
<programlisting>
}
</programlisting>

The file that contains the filter functions and format strings may be
compiled with the GNU compiler options <literal>"-fPIC -shared -rdynamic"
</literal> to produce a valid shared object.
</para>

<para>
A front-end that will dynamically load filters must be built
with the GNU compiler options <literal>"-Wl,-E"</literal> to notify the linker
export global symbols externally.
</para>

</sect1>

</chapter>
