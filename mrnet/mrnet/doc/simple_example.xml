<chapter id="simple_example"><title>A Simple Example</title>
<sect1><title>The MRNet Interface</title>
<para>
A complete description of the MRNet API is in <xref linkend="mrnet_api"></xref>. This section offers a brief overview only.
Using <filename>libmrnet.a</filename>, a tool can leverage a system of internal
processes, instances of the <filename>mrnet_commnode</filename> program, as a
communication substrate. After instantiation of the MRNet network (discussed in
<xref linkend="mrnet_instantiation"></xref>, the front-end and back-end
processes are connected by the internal processes. The connection topology and
host assignment of these processes is determined by a configuration file, thus
the
geometry of MRNet's process tree can be customized to suit the physical topology
of the underlying hardware resources. While MRNet can generate a variety of
standard topologies, users can easily specify their own topologies; see <xref
linkend="mrnet_topology_configuration"></xref> for further discussion.
</para>

<para>
The MRNet API, provided by libmrnet, contains network, end-point, communicator,
and stream objects that a tool's front-end and back-end use for communication.
The network object is used to instantiate the MRNet network and access end-point
objects that represent available tool back-ends. The communicator object is a
container for groups of end-points, and streams are used to send data to the
end-points in a communicator.
</para>

<figure id="fe_code"><title>MRNet Front-end Sample Code</title>
<programlisting>
   front_end_main(){
1.   MR_Network * net;
2.   MR_Communicator * comm;
3.   MR_Stream * stream;
4.   float result;
5.   net = new MR_Network(config_file);
6.   comm = net->get_broadcast_communicator( );
7.   stream = new MR_Stream(comm, FMAX_FIL);
8.   stream->send("%d", FLOAT_MAX_INIT);
9.   stream->recv("%f", result);
   }
</programlisting>
</figure>

<para>
A simplified version of code from an example tool front-end is shown in
<xref linkend="fe_code"></xref>. In the front-end code, after some variable
definitions in lines 1-4, in line 5, an instance of the MRNet network is created
using the topology specification in config_file. In line 6, the newly created
network object is queried for an auto-generated broadcast communicator that
contains all available end-points. In line 7, this communicator is used to
established a stream for which the MRNet internal processes will use a filter
that finds the
maximum floating point data value of the data sent upstream. The front-end then
might send one or more initialization messages to the backends; in our example
code on line 9, we broadcast an integer initializer and await the single
floating point value result.
</para>

<figure id="be_code"><title>MRNet Back-end Sample Code</title>
<programlisting>
   back_end_main(){
1.   MR_Stream * stream;
2.   int val;
3.   MR_Network::init_backend( );
4.   MR_Stream::recv("%d", &amp;val, &amp;stream);
5.   if(val == FLOAT_MAX_INIT){
6.      stream->send("%f", rand_float);
     }
   }
</programlisting>
</figure>

<para>
<xref linkend="be_code"></xref> shows the code for the back-end that 
reciprocates the actions of the front-end. Each tool back-end
first connects to the appropriate internal process, via the init_backend call
in line 3. While the front-end makes a stream-specific recv call, the back-ends
make a stream-anonymous recv that returns the integer sent by the front-end
along with a stream object representing the stream that the front-end has
established. Finally, each back-end sends a scalar floating point value
upstream toward the front-end.
</para>

<para>
A complete example of MRNet code can be found in <xref linkend="example">
</xref>.
</para>
</sect1>

<sect1 id="mrnet_instantiation"><title>MRNet Instantiation</title>
<para>
While conceptually simple, creating and connecting the internal processes is
complicated by interactions with the various job scheduling systems. In the
simplest environments, we can launch jobs manually using facilities like rsh
or ssh. In more complex environments, it is necessary to submit all requests
to a job management system. In this case, we are constrained by the operations
provided by the job manager (and these vary from system to system). We
currently support two modes of instantiating MRNet-based tools.
</para>

<para>
In the first mode of process instantiation, MRNet creates the internal and
back-end processes, using the specified MRNet topology configuration to
determine the hosts on which the components should be located. First, the
front-end consults the configuration and uses rsh or ssh to create internal
processes for the first level of the communication tree on the appropriate
hosts. Upon instantiation, the newly created processes establish a network
connection to the process that created it. The first activity on this
connection is a message from parent to child containing the portion of the
configuration relevant to that child. The child then uses this information to
begin instantiation of the sub-tree rooted at that child. When a sub-tree has
been established, the root of that sub-tree sends a report to its parent
containing the end-points accessible via that sub-tree. Each internal node
establishes its children processes and their respective connections
sequentially. However, since the various processes are expected to run on
different compute nodes, sub-trees in different branches of the network are
created in concurrently, maximizing the efficiency of network instantiation.
</para>

<para>
In the second mode of process instantiation, MRNet relies on a process
management system to create some or all of the MRNet processes. This mode
accommodates tools that require their back-ends to create, monitor, and
control the application processes. For example, IBM's POE uses environment
variables to pass information, such as the process' rank within the
application's global MPI communicator, to the MPI run-time library in each
application process. In cases like this, MRNet cannot provide back-end
processes with the environment necessary to start MPI application processes.
As a result, MRNet creates its internal processes recursively as in the first
instantiation mode, but does not instantiates any back-end processes. MRNet
then starts the tool back-ends using the process management system to ensure
they have the environment needed to create application processes successfully.
When starting the back-ends, MRNet must provide them with the information
needed to connect to the MRNet internal process tree, such as the leaf
processes' host names and connection port numbers. This information is
provided via the environment, using shared filesystems or other information
services as available on the target system.
</para>
</sect1>
</chapter>
