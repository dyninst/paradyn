<chapter id="simple_example"><title>A Simple Example</title>
<sect1><title>The MRNet Interface</title>
<para>
A complete description of the MRNet API is in <xref linkend="mrnet_api"></xref>. This section offers a brief overview only.
Using <filename>libmrnet.a</filename>, a tool can leverage a system of internal
processes, instances of the <filename>mrnet_commnode</filename> program, as a
communication substrate. After instantiation of the MRNet network (discussed in
<xref linkend="mrnet_instantiation"></xref>, the front-end and back-end
processes are connected by the internal processes. The connection topology and
host assignment of these processes is determined by a configuration file, thus
the
geometry of MRNet's process tree can be customized to suit the physical topology
of the underlying hardware resources. While MRNet can generate a variety of
standard topologies, users can easily specify their own topologies; see <xref
linkend="mrnet_topology_configuration"></xref> for further discussion.
</para>

<para>
The MRNet API contains network, end-point, communicator,
and stream objects that a tool's front-end and back-end use for communication.
The network object is used to instantiate the MRNet network and access end-point
objects that represent available tool back-ends. The communicator object is a
container for groups of end-points, and streams are used to send data to the
end-points in a communicator.
</para>

<example id="fe_code"><title>MRNet Front-end Sample Code</title>
<programlisting>
   front_end_main(...) {
1.     Network * net;
2.     Communicator * comm;
3.     Stream * stream;
4.     PacketPtr packet;
5.     int tag = FirstApplicationTag;
6.     float result;

7.     net = new Network(topol_config_file, backend_exe, backend_argv);

8.     comm = net->get_BroadcastCommunicator( );

9.     stream = net->new_Stream(comm, TFILTER_MAX);

10.    stream->send(tag, "%d", FLOAT_MAX_INIT);

11.    stream->recv(&amp;tag, packet)

12.    packet->unpack("%f", &amp;result);
   }
</programlisting>
</example>

<para>
A simplified version of code from an example tool front-end is shown in
<xref linkend="fe_code"></xref>. In the front-end code, after some variable
definitions in lines 1-6, an instance of the MRNet network is created
on line 7 using the topology specification in topol_config_file. In line 8, the newly created
network object is queried for an auto-generated broadcast communicator that
contains all available end-points. In line 9, this communicator is used to
establish a stream for which the MRNet internal processes will use a built-in 
filter that finds the maximum value of the data sent upstream. The front-end then
sends one or more initialization messages to the backends; in our example
code on line 10, we broadcast an integer initializer on the new stream. 
The tag parameter is an application-specific value denoting the nature of the message being 
transmitted. After the send operation, the front-end performs a blocking stream receive
at line 11. This call returns a tag and a packet. Finally, line 12 calls unpack to 
deserialize the floating point value contained in packet.
</para>

<example id="be_code"><title>MRNet Back-end Sample Code</title>
<programlisting>
   back_end_main(int argc, char** argv) {
1.     Stream * stream;
2.     PacketPtr packet;
3.     int val, tag;
4.     float random_float = (float) random( );

5.     Network * net = new Network(argc,argv);

6.     net->recv(&amp;tag, packet, &amp;stream);

7.     packet->unpack("%d", &amp;val );

8.     if( val == FLOAT_MAX_INIT )
9.         stream->send(tag, "%f", random_float);
   }
</programlisting>
</example>

<para>
<xref linkend="be_code"></xref> shows the code for the back-end that 
reciprocates the actions of the front-end. Each tool back-end
first connects to the appropriate internal process in line 5, 
using the back-end version of the network constructor that receives its 
arguments via the program argument vector (argc/argv). While the front-end makes 
a stream-specific receive call, the back-ends use a stream-anonymous network receive 
that returns the tag sent by the front-end, the packet containing the actual data 
sent, and a stream object representing the stream that the front-end has established. 
Finally, each back-end sends a scalar floating point value upstream toward the front-end.
</para>

<para>
A complete example of MRNet code can be found below in <xref linkend="example">.
Additionally, the MRNet distribution provides two examples and many tests that
demonstrate the use of the MRNet API by front-ends and back-ends. 
</xref>.
</para>
</sect1>

<sect1 id="mrnet_instantiation"><title>MRNet Instantiation</title>
<para>
While conceptually simple, creating and connecting the internal processes is
complicated by interactions with the various job scheduling systems. In the
simplest environments, we can launch jobs manually using facilities like rsh
or ssh. In more complex environments, it is necessary to submit all requests
to a job management system. In this case, we are constrained by the operations
provided by the job manager (and these vary from system to system). We
currently support two modes of instantiating MRNet-based tools.
</para>

<para>
In the first mode of process instantiation, MRNet creates the internal and
back-end processes, using the specified MRNet topology configuration to
determine the hosts on which the components should be located. First, the
front-end consults the configuration and uses rsh or ssh to create internal
processes for the first level of the communication tree on the appropriate
hosts. Upon instantiation, the newly created processes establish a network
connection to the process that created it. The first activity on this
connection is a message from parent to child containing the portion of the
configuration relevant to that child. The child then uses this information to
begin instantiation of the sub-tree rooted at that child. When a sub-tree has
been established, the root of that sub-tree sends a report to its parent
containing the end-points accessible via that sub-tree. Each internal node
establishes its children processes and their respective connections
sequentially. However, since the various processes are expected to run on
different compute nodes, sub-trees in different branches of the network are
created concurrently, maximizing the efficiency of network instantiation.
</para>

<para>
In the second mode of process instantiation, MRNet relies on a process
management system to create some or all of the MRNet processes. This mode
accommodates tools that require their back-ends to create, monitor, and
control other processes. For example, IBM's POE uses environment
variables to pass information, such as the process' rank within the
application's global MPI communicator, to the MPI run-time library in each
application process. In cases like this, MRNet cannot provide back-end
processes with the environment necessary to start MPI application processes.
As a result, MRNet creates its internal processes recursively as in the first
instantiation mode, but does not instantiate any back-end processes. MRNet
then starts the tool back-ends using the process management system to ensure
they have the environment needed to create application processes successfully.
When starting the back-ends, the front-end must provide them with the information
needed to connect to the MRNet internal processes, such as the leaf
processes' host names and connection port numbers. This information can be
provided via the environment, using shared filesystems or other information
services as available on the target system. To collect the necessary information,
the front-end can use the MRNet API methods for discovering the network topology
details.
</para>
</sect1>
</chapter>
