/* $Log: UImain.C,v $
/* Revision 1.64  1995/11/08 06:24:15  tamches
/* removed some warnings
/*
 * Revision 1.63  1995/11/08 05:10:03  tamches
 * removed reference to obsolete file dag.h
 *
 * Revision 1.62  1995/11/06 02:40:19  tamches
 * added an include to tkTools.h
 * removed several warnings
 * UImain() no longer takes in any args
 *
 * Revision 1.61  1995/11/01 20:39:39  naim
 * We should not need to kill visi processes from here. Eliminating the code
 * we have added previously for this and re-doing things more properly - naim
 *
 * Revision 1.60  1995/10/30  23:06:32  naim
 * Minor fix: eliminating error message "Error not handle, exiting" at the end
 * of paradyn by destroying all visi processes before exiting - naim
 *
 * Revision 1.59  1995/10/19  22:41:05  mjrg
 * Added callback function for paradynd's to report change in status of application.
 * Added Exited status for applications.
 *
 * Revision 1.58  1995/10/17  20:46:39  tamches
 * Changes for new search history graph.
 * Remove some obsolete variables such as uim_rootRes
 *
 * Revision 1.57  1995/10/09 18:16:00  naim
 * Minor fix to path variable "temp". I had changed it by mistake! - naim
 *
 * Revision 1.56  1995/10/05  04:36:23  karavan
 * getDagToken() obsoleted.
 *
 * Revision 1.55  1995/09/26  20:25:25  naim
 * Minor warning fixes and other minor fixes related to error messages
 *
 * Revision 1.54  1995/08/30  04:56:26  tamches
 * Added a processPendingTkEventsNoBlock() before msg_poll()
 *
 * Revision 1.53  1995/08/16  01:36:32  tamches
 * Added a tkProcessPendingEventsNoBlock() to the bottom end of the
 * main loop; for some unexplained reason, tk events generated by
 * the latter 3 cases of the UIthread main loop are not caught by the
 * subsequent thr_poll() until the mouse is moved in the paradyn
 * main window.
 *
 * Revision 1.52  1995/08/13  23:21:21  tamches
 * Moved tcl/tk initialization to pdMain
 *
 * Revision 1.51  1995/08/13  01:41:05  tamches
 * Tightened and heavily commented the main loop.
 * Removed superfluous code; general cleaning up.
 *
 * Revision 1.50  1995/08/05  17:10:19  krisna
 * deleted prototype for `strrchr', this file is anyway bogus
 *
 * Revision 1.49  1995/08/04 19:13:55  tamches
 * Added a status line for 'rethinking' after receiving data (whethere batch
 * mode or not)
 *
 * Revision 1.48  1995/07/24  21:30:40  tamches
 * added a useful status line for the ui (when it's receiving where axis
 * data)
 *
 * Revision 1.47  1995/07/18  19:14:29  krisna
 * changes to convert Tcl sources to C
 *
 * Revision 1.46  1995/07/17 05:05:44  tamches
 * Changes for the new version of the where axis
 *
 * Revision 1.45  1995/06/02  20:50:35  newhall
 * made code compatable with new DM interface
 *
 * Revision 1.43  1995/02/27  18:55:43  tamches
 * Minor include change to placate compiler.
 *
 * Revision 1.42  1995/02/16  08:20:48  markc
 * Changed Boolean to bool
 * Changed wait loop code for igen messages
 *
 * Revision 1.41  1995/01/26  17:58:57  jcargill
 * Changed igen-generated include files to new naming convention; fixed
 * some bugs compiling with gcc-2.6.3.
 *
 * Revision 1.40  1994/11/08  07:50:43  karavan
 * Purified code; narrowed side margins for dag nodes.
 *
 * Revision 1.39  1994/11/07  07:26:58  karavan
 * changed requested main window size.
 *
 * Revision 1.38  1994/11/03  22:18:42  karavan
 * eliminated redundancy in status display
 *
 * Revision 1.37  1994/11/03  20:25:05  krisna
 * added status_lines for application name and application status
 *
 * Revision 1.36  1994/11/03  06:16:14  karavan
 * status display and where axis added to main window and the look cleaned
 * up a little bit.  Added option to ResourceDisplayObj class to specify
 * a parent window for an RDO with the constructor.
 *
 * Revision 1.35  1994/11/03  02:44:58  krisna
 * status lines are now added into paradyn.
 *
 * Revision 1.34  1994/11/02  04:42:55  karavan
 * cleanup for new handling of commandline arguments
 *
 * Revision 1.33  1994/11/01  22:39:27  karavan
 * changed debugging printf to call to PARADYN_DEBUG
 *
 * Revision 1.32  1994/11/01  05:42:32  karavan
 * some minor performance and warning fixes
 *
 * Revision 1.31  1994/10/25  17:57:32  karavan
 * added Resource Display Objects, which support display of multiple resource
 * abstractions.
 *
 * Revision 1.30  1994/10/09  01:24:47  karavan
 * A large number of changes related to the new UIM/visiThread metric&resource
 * selection interface and also to direct selection of resources on the
 * Where axis.
 *
 * Revision 1.29  1994/09/30  19:18:28  rbi
 * Abstraction interface change.
 *
 * Revision 1.28  1994/09/05  20:04:49  jcargill
 * Fixed read-before-write of thread stack data (spotted by purify)
 *
 * Revision 1.27  1994/08/30  16:23:17  karavan
 * added "silent" node trimming to the base where axis.
 *
 * Revision 1.26  1994/08/05  16:04:25  hollings
 * more consistant use of stringHandle vs. char *.
 *
 * Revision 1.25  1994/08/01  20:24:39  karavan
 * new version of dag; new dag support commands
 *
 * Revision 1.24  1994/07/28  22:32:16  krisna
 * proper starting sequence for UImain thread
 *
 * Revision 1.23  1994/07/25  14:58:14  hollings
 * added suppress resource option.
 *
 * Revision 1.22  1994/07/07  17:40:33  karavan
 * added error and batchmode features.
 *
 * Revision 1.21  1994/06/29  21:46:25  hollings
 * Removed dead variable.
 *
 * Revision 1.20  1994/06/29  02:56:42  hollings
 * AFS path changes
 *
 * Revision 1.19  1994/06/27  21:25:17  rbi
 * New abstraction parameter for performance streams
 *
 * Revision 1.18  1994/06/17  22:08:07  hollings
 * Added code to provide upcall for resource batch mode when a large number
 * of resources is about to be added.
 *
 * Revision 1.17  1994/06/12  22:37:11  karavan
 * implemented status change for run/pause buttons.
 * bug fix:  node labels may now contain tcl special characters, eg [].
 *
 * Revision 1.16  1994/05/31  19:11:47  hollings
 * Changes to permit direct access to resources and resourceLists.
 *
 * Revision 1.15  1994/05/26  20:57:16  karavan
 * added tcl variable for location of bitmap files.
 *
 * Revision 1.14  1994/05/23  01:59:31  karavan
 * added callbacks for resource notification and state change notification.
 *
 * Revision 1.13  1994/05/12  23:34:13  hollings
 * made path to paradyn.h relative.
 *
 * Revision 1.12  1994/05/10  03:57:49  hollings
 * Changed data upcall to return array of buckets.
 *
 * Revision 1.11  1994/05/07  23:27:21  karavan
 * eliminated [location-dependent] tcl init file.
 *
 * Revision 1.10  1994/05/05  23:35:00  karavan
 * changed tcl calls to procedures.  removed conflicting def'n of read.
 * changed name of tcl initialization script.
 *
 * Revision 1.9  1994/05/02  20:38:30  hollings
 * added search pause command and shg commands.
 *
 * Revision 1.8  1994/04/21  23:24:50  hollings
 * added process command.
 *
 * Revision 1.7  1994/04/21  19:42:51  karavan
 * the *working* version, this time!
 *
 * Revision 1.6  1994/04/21  19:17:59  karavan
 * Added initialization of tcl dag command.
 *
 * Revision 1.5  1994/04/13  01:33:04  markc
 * Changed pointer to .tcl file.
 *
 * Revision 1.4  1994/04/06  22:39:57  markc
 * Added code to provide local paradynd with a machine name via
 * addExecutable.
 *
 * Revision 1.3  1994/04/06  17:39:56  karavan
 * added call to tcl initialization script
 *
 * Revision 1.2  1994/04/05  23:49:21  rbi
 * Fixed a bunch of tcl related stuff.
 *
 * Revision 1.1  1994/04/05  04:42:35  karavan
 * initial version of UI thread code and tcl paradyn command
 * */

/* UImain.C
 *    This is the main routine for the User Interface Manager thread, 
 *    called at thread creation.
 */

/*
 * Copyright (c) 1993, 1994 Barton P. Miller, Jeff Hollingsworth,
 *     Bruce Irvin, Jon Cargille, Krishna Kunchithapadam, Karen
 *     Karavanic, Tia Newhall, Mark Callaghan.  All rights reserved.
 * 
 * This software is furnished under the condition that it may not be
 * provided or otherwise made available to, or used by, any other
 * person, except as provided for by the terms of applicable license
 * agreements.  No title to or ownership of the software is hereby
 * transferred.  The name of the principals may not be used in any
 * advertising or publicity related to this software without specific,
 * written prior authorization.  Any use of this software must include
 * the above copyright notice.
 *
 */

#include "tclclean.h"
#include "tkclean.h"

#include "util/h/headers.h"
#include <sys/param.h>

#include "UIglobals.h" 
#include "paradyn/src/DMthread/DMinclude.h"
#include "dataManager.thread.h"
#include "thread/h/thread.h"
#include "../pdMain/paradyn.h"

#include "paradyn/src/TCthread/tunableConst.h"

#include "abstractions.h"
#include "whereAxisTcl.h"
#include "shgTcl.h"
#include "tkTools.h"

bool haveSeenFirstGoodWhereAxisWid = false;
bool tryFirstGoodWhereAxisWid(Tcl_Interp *interp, Tk_Window topLevelTkWindow) {
   if (haveSeenFirstGoodWhereAxisWid)
      return true;

   Tk_Window theTkWindow = Tk_NameToWindow(interp, ".whereAxis.nontop.main.all",
                                           topLevelTkWindow);
   assert(theTkWindow);

   if (Tk_WindowId(theTkWindow) == 0)
      return false; // sigh...still invalid (that's why this routine is needed)

   haveSeenFirstGoodWhereAxisWid = true;

   extern abstractions *theAbstractions; // whereAxisTcl.C
   theAbstractions = new abstractions(".whereAxis.top.mbar.abs.m",
				      ".whereAxis.top.mbar.nav.m",
				      ".whereAxis.nontop.main.bottsb",
				      ".whereAxis.nontop.main.leftsb",
				      ".whereAxis.nontop.find.entry",
				      interp, theTkWindow);
   assert(theAbstractions);

   return true;   
}


/*
 * Global variables used by tcl/tk UImain program:
 */

extern Tk_Window mainWindow;	/* The main window for the application.  If
				 * NULL then the application no longer
				 * exists. */
extern Tcl_Interp *interp;	/* Interpreter for this application. */

static Tcl_DString command;	/* Used to assemble lines of terminal input
				 * into Tcl commands. */
extern int tty;			/* Non-zero means standard input is a
				 * terminal-like device.  Zero means it's
				 * a file. */

//resourceHandle            uim_rootRes;
int                       uim_eid;
List<metricInstInfo *> uim_enabled;
perfStreamHandle          uim_ps_handle;
UIM                       *uim_server;
int uim_maxError;
int uim_ResourceSelectionStatus;
int UIM_BatchMode = 0;
Tcl_HashTable UIMMsgReplyTbl;
Tcl_HashTable UIMwhereDagTbl;
int UIMMsgTokenID;
appState PDapplicState = appPaused;     // used to update run/pause buttons  

status_line *ui_status=NULL;
status_line *app_status=NULL;

/*
 * Declarations for various library procedures and variables 
 */

//extern "C" {
//  int Tk_DagCmd _ANSI_ARGS_((ClientData clientData,
//        Tcl_Interp *interp, int argc, char **argv));
//}

extern int UimpdCmd(ClientData clientData, 
		Tcl_Interp *interp, 
		int argc, 
		char *argv[]);
extern int ParadynCmd(ClientData clientData, 
		Tcl_Interp *interp, 
		int argc, 
		char *argv[]);
extern void resourceAddedCB (perfStreamHandle handle, 
		      resourceHandle parent, 
		      resourceHandle newResource, 
		      const char *name,
		      const char *abstraction);

/*
 * Forward declarations for procedures defined later in this file:
 */

void             Prompt _ANSI_ARGS_((Tcl_Interp *interp, int partial));
void             StdinProc _ANSI_ARGS_((ClientData clientData,
					int mask));

// This callback invoked by dataManager before and after a large 
// batch of draw requests.
// I'm not sure what the perfStreamHandle argument is for --ari
 
void resourceBatchChanged(perfStreamHandle, batchMode mode)
{
    if (mode == batchStart) {
      ui_status->message("receiving where axis items [batch mode]");

      UIM_BatchMode++;
      // cout << "+" << endl; cout.flush();
    } else {
      UIM_BatchMode--;
      // cout << "-" << endl; cout.flush();
      if (UIM_BatchMode == 0) {
         // Batch mode is done with.  We need to update the where axis'
         // spatial graphications...
         ui_status->message("Rethinking after batch mode");

         extern abstractions *theAbstractions;
         assert(theAbstractions);

         theAbstractions->resizeEverything();
            // super-expensive

         initiateWhereAxisRedraw(interp, true); // true--> double buffer

         ui_status->message("ready");

         // Shouldn't we also Tcl_Eval(interp, "update"), to process any
         // pending idle events?
      }
    }
    assert(UIM_BatchMode >= 0);
}

void
applicStateChanged (perfStreamHandle, appState state) 
{
  if (! app_status) {
    app_status = new status_line("Application status");
  }
 
  if ((state == appRunning) && (PDapplicState == appPaused)) { 
    if (Tcl_VarEval (interp, "changeApplicState 1", 0) == TCL_ERROR) {
      printf ("changeApplicStateERROR: %s\n", interp->result);
    }
    app_status->state(status_line::NORMAL);
    app_status->message("RUNNING");
  } else if ((state == appPaused) && (PDapplicState == appRunning)) {
    if (Tcl_VarEval (interp, "changeApplicState 0", 0) == TCL_ERROR) {
      printf ("changeApplicStateERROR: %s\n", interp->result);
    }
    app_status->state(status_line::URGENT);
    app_status->message("PAUSED");
  } else if ((state == appExited)) {
    app_status->state(status_line::URGENT);
    app_status->message("EXITED");
  }
  PDapplicState = state;
}


/*
 *----------------------------------------------------------------------
 *
 * UImain --
 *
 *	Main program for UI thread
 *
 * Side effects:
 *	This procedure initializes the wish world and then starts
 *	interpreting commands;  almost anything could happen, depending
 *	on the script being interpreted.
 *
 *----------------------------------------------------------------------
 */

void panic(const char *msg) {
   cerr << msg << endl;
   exit(5);
}

void processPendingTkEventsNoBlock() {
   // We use Tk_DoOneEvent (w/o blocking) to soak up and process
   // pending tk events, if any.  Returns as soon as there are no
   // tk events to process.
   // NOTE: This includes (as it should) tk idle events.
   // NOTE: This is basically the same as Tcl_Eval(interp, "update"), but
   //       who wants to incur the expense of tcl parsing?

   while (Tk_DoOneEvent(TK_DONT_WAIT) > 0)
      ;
}

void *UImain(void*) {
    tag_t mtag;
    int retVal;
    unsigned msgSize = 0;
    char UIMbuff[UIMBUFFSIZE];
    controlCallback controlFuncs;
    dataCallback dataFunc;

    // Add internal UIM command to the tcl interpreter.
    Tcl_CreateCommand(interp, "uimpd", 
		      UimpdCmd, (ClientData) mainWindow,
		      (Tcl_CmdDeleteProc *) NULL);

    // add Paradyn tcl command to active interpreter
    Tcl_CreateCommand(interp, "paradyn", ParadynCmd, (ClientData) NULL,
		      (Tcl_CmdDeleteProc *) NULL);

    /* tell interpreter where the tcl files are */
    const char *temp;
    if ((temp = getenv("PARADYNTCL")) != 0) {
        if (Tcl_VarEval (interp, "set auto_path [linsert $auto_path 0 ",
		 temp, "]", 0) == TCL_ERROR)
          printf ("can't set auto_path: %s\n", interp->result);
    }
    if (temp == 0) {
	temp = "/p/paradyn/core/paradyn/tcl";
    }
    Tcl_SetVar (interp, "PdBitmapDir", temp, 0); // YUCK --ari

/*
 * load all converted Tcl sources into the interpreter.
 * the function `initialize_tcl_sources(Tcl_Interp *)' is automatically
 * generated by `tcl2c'.
 *
 */
    extern int initialize_tcl_sources(Tcl_Interp *);
    if (initialize_tcl_sources(interp) != TCL_OK) {
        fprintf(stderr, "initialize_tcl_sources: ERROR in Tcl sources, exitting\n");
        exit(-1);
    }
//assert(TCL_OK==Tcl_EvalFile(interp, "/p/paradyn/development/tamches/core/paradyn/tcl/shg.tcl"));
//assert(TCL_OK==Tcl_EvalFile(interp, "/p/paradyn/development/tamches/core/paradyn/tcl/mainMenu.tcl"));
//assert(TCL_OK==Tcl_EvalFile(interp, "/p/paradyn/development/tamches/core/paradyn/tcl/whereAxis.tcl"));
//assert(TCL_OK==Tcl_EvalFile(interp, "/p/paradyn/development/tamches/core/paradyn/tcl/tclTunable.tcl"));
//assert(TCL_OK==Tcl_EvalFile(interp, "/p/paradyn/development/tamches/core/paradyn/tcl/applic.tcl"));
//assert(TCL_OK==Tcl_EvalFile(interp, "/p/paradyn/development/tamches/core/paradyn/tcl/status.tcl"));


   /* display the paradyn main menu tool bar */
    if (Tcl_VarEval (interp, "drawToolBar", 0) == TCL_ERROR)
      printf ("NOTOOLBAR:: %s\n", interp->result);
     // initialize number of errors read in from error database 
    uim_maxError = atoi(Tcl_GetVar (interp, "numPdErrors", 0));

    // bind stdin to this thread & setup command-line input w/prompt
    retVal = msg_bind (fileno(stdin),
		       1 // "special" flag --> libthread leaves it to us to manually
                         // dequeue these messages
		       );

    // Initialize "command", an important global variable that accumulates
    // a typed-in line of data.  It gets updated in StdinProc(), below.
    Tcl_DStringInit(&command);
    if (tty)
      Prompt(interp, 0);

    // Initialize UIM thread as UIM server 
    thr_name ("UIM");
    uim_server = new UIM(MAINtid);

    // register fd for X events with threadlib as special
    Display *UIMdisplay = Tk_Display (mainWindow);
    int xfd = XConnectionNumber (UIMdisplay);
    retVal = msg_bind (xfd,
		       1 // "special" flag --> libthread leaves it to us to manually
                         // dequeue these messages
		       );

    // initialize hash table for async call replies
    Tcl_InitHashTable (&UIMMsgReplyTbl, TCL_ONE_WORD_KEYS);
    UIMMsgTokenID = 0;

    // wait for all other main module threads to complete initialization
    //  before continuing.

    retVal = msg_send (MAINtid, MSG_TAG_UIM_READY, (char *) NULL, 0);
    mtag = MSG_TAG_ALL_CHILDREN_READY;
    retVal = msg_recv (&mtag, UIMbuff, &msgSize);

    PARADYN_DEBUG(("UIM thread past barrier\n"));

    // subscribe to DM new resource notification service
//    resourceHandle *rhptr = dataMgr->getRootResource();
//    if (rhptr == (resourceHandle *)NULL)
//       panic("dataMgr->getRootResource() failed");

//    uim_rootRes = *rhptr;
    controlFuncs.rFunc = resourceAddedCB;
    controlFuncs.mFunc = NULL;
    controlFuncs.fFunc = NULL;
    controlFuncs.sFunc = applicStateChanged;
    controlFuncs.bFunc = resourceBatchChanged;
    controlFuncs.pFunc = NULL;
    dataFunc.sample = NULL;

    uim_ps_handle = dataMgr->createPerformanceStream
      (Sample, dataFunc, controlFuncs);
    
    // New Where Axis: --ari
    installWhereAxisCommands(interp);
    if (TCL_ERROR == Tcl_Eval(interp, "whereAxisInitialize"))
       tclpanic(interp, "Could not whereAxisInitialize");

    // New Search History Graph: --ari
    installShgCommands(interp);
//    if (TCL_ERROR == Tcl_Eval(interp, "shgInitialize"))
//       tclpanic(interp, "Could not shgInitialize");

    //
    // initialize status lines library
    // it is assumed that by this point, all the appropriate
    // containing frames have been created and packed into place
    //
    // after this point onwards, any thread may make use of
    // status lines.
    // if any thread happens to create status_lines before here,
    // it should be prepared for a core dump.
    //
    // --krishna
    //
    status_line::status_init(interp);

    ui_status = new status_line("UIM status");
    assert(ui_status);
    ui_status->message("ready");

/*******************************
 *    Main Loop for UIM thread.  
 ********************************/

   while (tk_NumMainWindows > 0) {
      processPendingTkEventsNoBlock();

      msgSize = UIMBUFFSIZE;
      mtag = MSG_TAG_ANY;
      int pollsender = msg_poll (&mtag, 1); // 1-->make this a blocking poll
                                            // i.e., not really a poll at all...
      // Why don't we do a blocking msg_recv() in all cases?  Probably
      // because it soaks up the pending message, which may (? my best guess ?)
      // throw off those mysterious dataMgr->waitLoop() and uim_server->waitLoop()
      // calls below.

      processPendingTkEventsNoBlock();

      // check for X events or commands on stdin
      if (mtag == MSG_TAG_FILE) {
         // Note: why don't we do a msg_recv(), to consume the pending
         //       event?  Because both of the MSG_TAG_FILEs we have set
         //       up have the special flag set (in the call to msg_bind()),
         //       which indicated that we, instead of libthread, will take
         //       responsibility for that.  In other words, a msg_recv()
         //       now would not dequeue anything, so there's no point in doing it...

	 if (pollsender == xfd)
            processPendingTkEventsNoBlock();
         else if (pollsender == fileno(stdin))
            // process all pending stdin events
            StdinProc((ClientData) NULL, 0);
         else
            cerr << "hmmm...unknown sender of a MSG_TAG_FILE message...ignoring" << endl;

         processPendingTkEventsNoBlock();
      }
      else  {
         // check for upcalls
         if (dataMgr->isValidTag((T_dataManager::message_tags)mtag)) {
            if (dataMgr->waitLoop(true, (T_dataManager::message_tags)mtag) ==
		T_dataManager::error) {
               // TODO
               assert(0);
	    }
         }
         else if (uim_server->isValidTag((T_UI::message_tags)mtag)) {
            // check for incoming client requests
            if (uim_server->waitLoop(true, (T_UI::message_tags)mtag) ==
	       T_UI::error) {
	      // TODO
	      assert(0);
            }
	 }
         else
            panic("ui main loop: neither dataMgr nor uim_server report isValidTag() of true");

         processPendingTkEventsNoBlock();
      }
   } 

   unInstallShgCommands(interp);
   unInstallWhereAxisCommands(interp);

   /*
    * Exiting this thread will signal the main/parent to exit.  No other
    * notification is needed.  This call will be reached when there are 
    * no windows remaining for the application -- either grievous error 
    * or user has selected "EXIT".
    */
   thr_exit(0);
   return ((void*)0);
}
    


/* The two procedures below are taken from the tcl/tk distribution and
 * the following copyright notice applies.
 */
/* 
 * Copyright (c) 1990-1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

/*
 *----------------------------------------------------------------------
 *
 * StdinProc --
 *
 *      This procedure is invoked by the event dispatcher whenever
 *      standard input becomes readable.  It grabs the next line of
 *      input characters, adds them to a command being assembled, and
 *      executes the command if it's complete.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Could be almost arbitrary, depending on the command that's
 *      typed.
 *
 *----------------------------------------------------------------------
 */

void
StdinProc(ClientData, int mask)
{
#define BUFFER_SIZE 4000
    char input[BUFFER_SIZE+1];
    static int gotPartial = 0;
    char *cmd;
    int code, count;

    count = read(fileno(stdin), input, BUFFER_SIZE);
    if (count <= 0) {
        if (!gotPartial) {
            if (tty) {
                Tcl_Eval(interp, "exit");
                exit(1);
            } else {
                Tk_DeleteFileHandler(0);
            }
            return;
        } else {
            count = 0;
        }
    }
    cmd = Tcl_DStringAppend(&command, input, count);
    if (count != 0) {
        if ((input[count-1] != '\n') && (input[count-1] != ';')) {
            gotPartial = 1;
            goto prompt;
        }
        if (!Tcl_CommandComplete(cmd)) {
            gotPartial = 1;
            goto prompt;
        }
    }
    gotPartial = 0;

    /*
     * Disable the stdin file handler while evaluating the command;
     * otherwise if the command re-enters the event loop we might
     * process commands from stdin before the current command is
     * finished.  Among other things, this will trash the text of the
     * command being evaluated.
     */

    Tk_CreateFileHandler(0, 0, StdinProc, (ClientData) 0);
    code = Tcl_RecordAndEval(interp, cmd, 0);
    Tk_CreateFileHandler(0, TK_READABLE, StdinProc, (ClientData) 0);
    Tcl_DStringFree(&command);
    if (*interp->result != 0) {
        if ((code != TCL_OK) || (tty)) {
            printf("%s\n", interp->result);
        }
    }

    /*
     * Output a prompt.
     */

    prompt:
    if (tty) {
        Prompt(interp, gotPartial);
    }
}
/*
 *----------------------------------------------------------------------
 *
 * Prompt --
 *
 *      Issue a prompt on standard output, or invoke a script
 *      to issue the prompt.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      A prompt gets output, and a Tcl script may be evaluated
 *      in interp.
 *
 *----------------------------------------------------------------------
 */

void
Prompt(Tcl_Interp *interp,   /* Interpreter to use for prompting. */
       int partial)          /* Non-zero means there already
                              * exists a partial command, so use
                              * the secondary prompt. */
{
    char *promptCmd;
    int code;

    promptCmd = Tcl_GetVar(interp,
        partial ? "tcl_prompt2" : "tcl_prompt1", TCL_GLOBAL_ONLY);
    if (promptCmd == NULL) {
        defaultPrompt:
        if (!partial) {
            fputs("pd> ", stdout);
        }
    } else {
        code = Tcl_Eval(interp, promptCmd);
        if (code != TCL_OK) {
            Tcl_AddErrorInfo(interp,
                    "\n    (script that generates prompt)");
            fprintf(stderr, "%s\n", interp->result);
            goto defaultPrompt;
        }
    }
    fflush(stdout);
  }

