/*
 * Copyright (c) 1996 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

extern "C" {
#include <malloc.h>
#include <stdio.h>
}
#include "DMmetric.h"
#include <iostream.h>

extern void histDataCallBack(sampleValue*, timeStamp, int, int, void*, bool);
extern void histFoldCallBack(timeStamp, void*, bool);

// trace data streams
extern void traceDataCallBack(void*, int, void*);

metric::metric(T_dyninstRPC::metricInfo i){

    if(allMetrics.defines(i.name)) return;
    info.style = i.style;
    info.units = i.units;
    info.name = i.name;
    info.developerMode = i.developerMode;
    info.unitstype = i.unitstype;
    info.aggregate = i.aggregate;
    info.handle = metrics.size();
    metric *met = this;
    allMetrics[i.name] = met;
    metrics += met;
}

const T_dyninstRPC::metricInfo *metric::getInfo(metricHandle handle) { 
   
    if(handle < metrics.size()){
        metric *met = metrics[handle];
        return(met->getInfo());
    }
    else{
        return 0 ;
    }
}

const char *metric::getName(metricHandle handle){
     if(handle < metrics.size()){
	metric *met = metrics[handle];
        return(met->info.name.string_of());
     }
     else{
        return 0 ;
     }
}

const metricHandle *metric::find(const string iName){ 
     if(allMetrics.defines(iName)){
        return(&(allMetrics[iName])->info.handle);
     }
     else{
        return 0 ;
     }
}

metric *metric::getMetric(metricHandle handle){ 
     if(handle < metrics.size()){
	return(metrics[handle]);
     }
     else{
        return 0 ;
     }
}

vector<string> *metric::allMetricNames(bool all){

    vector<string> *temp = new vector<string>;
    string name;
    tunableBooleanConstant developerMode =
			   tunableConstantRegistry::findBoolTunableConstant(
			   "developerMode");
    bool developerModeActive = developerMode.getValue();
    for(unsigned i=0; i < metrics.size(); i++){
        metric *met = metrics[i];
        if (all || developerModeActive) {
	  string name = met->getName();
	  *temp += name;
        }
	else if (!met->isDeveloperMode()) {
	  string name = met->getName();
	  *temp += name;
        }
    }
    return(temp);
}

vector<met_name_id> *metric::allMetricNamesIds(bool all){

    vector<met_name_id> *temp = new vector<met_name_id>;
    met_name_id next;
    tunableBooleanConstant developerMode =
			   tunableConstantRegistry::findBoolTunableConstant(
		           "developerMode");
    bool developerModeActive = developerMode.getValue();

    for(unsigned i=0; i < metrics.size(); i++){
        metric *met = metrics[i];
	if (all || developerModeActive) {
          next.name = met->getName();
	  next.id = met->getHandle();
	  *temp += next; 
        }
        else if (!met->isDeveloperMode()) {
	  next.name = met->getName();
	  next.id = met->getHandle();
	  *temp += next;
        }
    }
    return(temp);
}

metricInstance::metricInstance(resourceListHandle rl, 
			       metricHandle m,
			       phaseHandle ph): 
    aggSample((metric::getMetric(m)->getAggregate())) {
    met = m;
    focus = rl;
    enabledTime = 0.0;
    //metric *mp = metric::getMetric(m);
    //sample.aggOp = mp->getAggregate();
    data = 0;
    global_data = 0;
    persistent_data = false;
    persistent_collection = false;
    phase_persistent_data = false;
    currEnablesWaiting = 0;
    globalEnablesWaiting = 0;
    enabled = false;
    currently_enabling = false;
    metricInstance::curr_phase_id = ph;
    id = next_id++;
    allMetricInstances[id] = this;

    // trace data streams
    traceFunc = 0;
}

metricInstance::~metricInstance() {
    for(unsigned i=0; i < components.size(); i++){
        delete (components[i]);    
    }
    // for(unsigned j=0; j < parts.size(); j++){
    //        delete (parts[j]);    
    // }
    for(unsigned k=0; k < old_data.size(); k++){
        delete (old_data[k]);    
    }
    if (data) delete(data);
    if (global_data) delete(global_data);
    // remove metricInstace from list of allMetricsInstances
    allMetricInstances.undef(id);
}

int metricInstance::getArchiveValues(sampleValue *buckets,int numOfBuckets,
				    int first,phaseHandle phase_id){

    // find histogram associated with phase_id
    for(unsigned i = 0; i < old_data.size(); i++){
        if((old_data[i])->phaseId == phase_id){
	    if((old_data[i])->data)
                return((old_data[i])->data->getBuckets(buckets,
						       numOfBuckets,first));
	}
    }
    return -1;
}

int metricInstance::getSampleValues(sampleValue *buckets,int numOfBuckets,
				    int first,phaseType phase){

    if(phase == CurrentPhase){
        if (!data) return (-1);
        return(data->getBuckets(buckets, numOfBuckets, first));
    }
    else {
        if (!global_data) return (-1);
        return(global_data->getBuckets(buckets, numOfBuckets, first));
    }

}

// 
// write out all data for a single histogram to specified file
// this routine assumes that fptr points to a valid file open for writing!  
//
void 
metricInstance::saveAllData (ofstream& fptr, phaseType ph)
{
  // first locate the histogram
  timeStamp width;
  Histogram *hdata;
  if (ph == GlobalPhase) {
    hdata = global_data;
    width = global_bucket_width;
  } else {
    hdata = data;
    width = curr_bucket_width;
  }
  if (hdata == NULL)
    // histogram not created yet for this MI
    return;

  string writeout;
  int numBins = hdata->getNumBins();
  sampleValue *buckets = new sampleValue [numBins];
  unsigned count = hdata->getBuckets(buckets, numBins, 0);
  // write header info:  numBuckets, bucketWidth
  fptr << numBins << " " << width << endl;
  // write all data values
  for (unsigned k = 0; k < count; k++) {
    fptr << string(buckets[k]) << endl;
  }

  if (ph == CurrentPhase) {
    // save archived data, if any
    for (unsigned i = 0; i < old_data.size(); i++) {
      hdata = (old_data[i])->data;
      if ( hdata ) {
	count = hdata->getBuckets(buckets, numBins, 0);
	// header info:  numBuckets, bucketWidth 
	fptr << numBins << " " << width << endl;
	// data
	for (unsigned k = 0; k < count; k++) {
	  fptr << buckets[k] << endl;
	}
      }
    }
  }
  delete buckets;
}


metricInstance *metricInstance::getMI(metricInstanceHandle mh){

    metricInstance* mih;
    bool found = allMetricInstances.find(mh, mih);
    if (found) {
        return mih;
    }
    return 0;
}

// TODO: remove asserts
void metricInstance::dataDisable(){
    
    assert(!users.size());
    assert(!global_users.size());
    for(unsigned i=0; i < components.size(); i++){
	aggSample.removeComponent(components[i]->sample);
        delete (components[i]);  // this disables data collection  
    }
    components.resize(0);
    // deleteing components deletes parts as well
    //    parts.resize(0);
    //    num_procs_per_part.resize(0);
    enabled = false;
    // if data is persistent this must be cleared 
    //    sample.firstSampleReceived = false;  
    assert(!components.size());
    //    assert(!parts.size());
}

void metricInstance::removeCurrUser(perfStreamHandle ps){

    // remove ps from vector of users
    unsigned size = users.size();
    for(unsigned i=0; i < size; i++){
	if(users[i] == ps){
	    users[i] = users[size-1];
	    users.resize(size-1);
	    assert(users.size() < size);
	    // decrease ps's data buffer size
	    performanceStream::removeCurrentUser(ps);
	    return;
    } }
}

void metricInstance::removeGlobalUser(perfStreamHandle ps){

    // remove ps from vector of users
    unsigned size = global_users.size();
    for(unsigned i=0; i < size; i++){
	if(global_users[i] == ps){
	    global_users[i] = global_users[size-1];
	    global_users.resize(size-1);
	    assert(global_users.size() < size);
	    // decrease ps's data buffer size
	    performanceStream::removeGlobalUser(ps);
	    return;
    } }
}

// trace data streams
void metricInstance::removeTraceUser(perfStreamHandle ps){

    // remove ps from vector of users
    unsigned size = trace_users.size();
    for(unsigned i=0; i < size; i++){
        if(trace_users[i] == ps){
            trace_users[i] = trace_users[size-1];
            trace_users.resize(size-1);
            assert(trace_users.size() < size);
            // decrease ps's data buffer size
            performanceStream::removeTraceUser(ps);
            return;
    } }
}

// returns true if histogram really was deleted
bool metricInstance::deleteCurrHistogram(){

    // if curr histogram exists and there are no users delete
    if(!(users.size()) && data) {
        delete data;
        data = 0;
	return true;
    }
    return false;
}

metricInstance *metricInstance::find(metricHandle mh, resourceListHandle rh){

    
    dictionary_hash_iter<metricInstanceHandle,metricInstance *> 
			allMI(allMetricInstances);
    metricInstanceHandle handle;
    metricInstance *mi;
    while(allMI.next(handle,mi)){
	if((mi->getMetricHandle() == mh) && (mi->getFocusHandle() == rh)){
	    return(mi);
	}
    }
    return 0;
}

//
// clears the persistent_data flag and deletes any histograms without 
// subscribers.  The values for num_global_hists and num_curr_hists are
// not changed because these are for active histograms, and this routine
// should not delete any histograms that are active.
// returns true if the metric instance can be deleted
//
bool metricInstance::clearPersistentData(){
  
    phase_persistent_data = false;
    // if there are no outstanding enables for this MI and the flag was set 
    if(persistent_data && !globalEnablesWaiting && !currEnablesWaiting){ 
       // if persistent collection is false then may need to delete data
       if(!persistent_collection){
	   // if there are no current subscribers delete curr. hist and 
	   // archieved histograms
	   if(users.size() == 0){
	       if(data){
	           delete data;
	           data = 0;
	       }
	       // delete any archived histograms
               for(unsigned k=0; k < old_data.size(); k++){
                   delete (old_data[k]);    
		   old_data.resize(0);
               }
	   }
           // if there are no curr. or global data subscribers and if
           // persistent_collection is false then delete the metric instance
	   if(!enabled){
               if((global_users.size() == 0) && global_data){ 
		   delete global_data;
		   global_data = 0;
                   persistent_data = false;
		   return true;
	       }
	   }
       }
    }
    persistent_data = false;
    return false;
}

bool metricInstance::addComponent(component *new_comp){

    paradynDaemon *new_daemon =  new_comp->getDaemon();
    for (unsigned i=0; i < components.size(); i++){
         if((components[i])->getDaemon() == new_daemon) return false;
    }
    components += new_comp;
    new_comp->sample = aggSample.newComponent();
    return true;
}

// remove the component correspondent to daemon
// If there are no more componets, flush aggregate samples, 
// and notify clients.
bool metricInstance::removeComponent(paradynDaemon *daemon) {
    unsigned size = components.size();
    for (unsigned u = 0; u < size; u++) {
      if (components[u]->getDaemon() == daemon) {
	aggSample.removeComponent(components[u]->sample);
	delete (components[u]);
	if (u < size-1) {
	  components[u] = components[size-1];
	}
	components.resize(size-1);
	if (size == 1) {
	  // the last component was removed
	  // flush aggregate samples
	  struct sampleInterval ret;
	  ret = aggSample.aggregateValues();
	  while (ret.valid) {
	    assert(ret.end >= 0.0);
	    assert(ret.start >= 0.0);
	    assert(ret.end >= ret.start);
	    enabledTime += ret.end - ret.start;
	    addInterval(ret.start, ret.end, ret.value, false);
	    ret = aggSample.aggregateValues();
	  }
	}
	return true;
      }
    }
    return false;
}

#ifdef notdef
bool metricInstance::addPart(sampleInfo *new_part){
    parts += new_part;
    u_int new_size = num_procs_per_part.size() + 1;
    num_procs_per_part.resize(new_size);
    assert(parts.size() == num_procs_per_part.size());
    return true;
}
#endif

// stops currentPhase data collection for all metricInstances
void metricInstance::stopAllCurrentDataCollection(phaseHandle last_phase_id) {

    dictionary_hash_iter<metricInstanceHandle,metricInstance *> 
			allMI(allMetricInstances);
    metricInstanceHandle handle;
    metricInstance *mi;
 
    vector<metricInstance *> remove_list;
    allMI.reset();
    while(allMI.next(handle,mi)){
	remove_list += mi;
    }
     
    assert(remove_list.size() == allMetricInstances.size());
    for(unsigned i=0; i < remove_list.size(); i++){
	mi = remove_list[i];
	mi->currEnablesWaiting = 0;
        // remove all users from user list
	mi->users.resize(0);
	assert(!(mi->users.size()));
	// clear the persistent flag that is only valid within a phase
	mi->clearPhasePersistentData();

	bool was_deleted = false;
        // if persistent data archive curr histogram
	if(mi->isDataPersistent()){
	    if (mi->data) {
	        if(mi->data->isActive()) was_deleted = true;	
	        mi->data->clearActive();
	        mi->data->clearFoldOnInactive();
	        ArchiveType *temp = new ArchiveType;
	        temp->data = mi->data;
	        temp->phaseId = last_phase_id; 
	        mi->old_data += temp;
	        mi->data = 0;
	        temp = 0; 
	    }
	}
	else { // else delete curr histogram
            was_deleted = mi->deleteCurrHistogram();
	}


        // if not persistent collection
	if (!(mi->isCollectionPersistent())){
	    // really disable data collection 
	    if((mi->isEnabled()) && (!mi->globalUsersCount())) { 
		// disable MI data collection 
		mi->dataDisable();
		if(!(mi->isDataPersistent())){
		    delete(mi);
		}
		metricInstance::decrNumGlobalHists();
            }
	    if(was_deleted)
	        metricInstance::decrNumCurrHists();
	}
	else { // else, create new curr histogram with empty curr users list
	    metric *m = metric::getMetric(mi->met);
	    mi->newCurrDataCollection(m->getStyle(),
				      histDataCallBack,
				      histFoldCallBack);
	}
    }
    // reduce each performance stream's buffer size by the number
    // of current MI's it will no longer be receiving data for
    performanceStream::removeAllCurrUsers();
}


void metricInstance::addCurrentUser(perfStreamHandle p) {

    for(unsigned i=0; i < users.size(); i++){
        if(users[i] == p) return;
    }
    users += p;
    assert(users.size());
    // update buffersize for perfStream
    performanceStream::addCurrentUser(p);
}

void metricInstance::addGlobalUser(perfStreamHandle p) {

    for(unsigned i=0; i < global_users.size(); i++){
        if(global_users[i] == p) return;
    }
    global_users += p;
    assert(global_users.size());
    // update buffersize for perfStream
    performanceStream::addGlobalUser(p);
}

// trace data streams
void metricInstance::addTraceUser(perfStreamHandle p) {

    for(unsigned i=0; i < trace_users.size(); i++){
        if(trace_users[i] == p) return;
    }
    trace_users += p;
    assert(trace_users.size());
    // update buffersize for perfStream
    performanceStream::addTraceUser(p);

}

// trace data streams
void metricInstance::newTraceDataCollection(dataCallBack2 dcb) {
    assignTraceFunc(dcb);
}

void metricInstance::newGlobalDataCollection(metricStyle style, 
					     dataCallBack dcb, 
					     foldCallBack fcb) {

    // histogram has already been created
    if (global_data) {
	global_data->setActive();
	global_data->clearFoldOnInactive();
	return;  
    }
    // call constructor for start time 0.0 
    global_data = new Histogram(style, dcb, fcb, this, 1);
}

void metricInstance::newCurrDataCollection(metricStyle style, 
					   dataCallBack dcb, 
					   foldCallBack fcb) {

    // histogram has already been created
    if (data) {
	data->setActive();
	data->clearFoldOnInactive();
        return;  
    }
    // create new histogram
    timeStamp start_time = phaseInfo::GetLastPhaseStart();
    if(start_time == 0.0) {
        data = new Histogram(style, dcb, fcb, this, 0);
	assert(data);
	phaseInfo::setCurrentBucketWidth(data->getBucketWidth());

    }
    else {
        data = new Histogram(start_time, style, dcb, fcb, this, 0);
	assert(data);
	phaseInfo::setCurrentBucketWidth(data->getBucketWidth());
    }
}

