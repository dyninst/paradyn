/*
 * Copyright (c) 1996 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

// $Id: DMresource.C,v 1.50 1999/08/09 05:40:09 csserra Exp $

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "dataManager.thread.h"
#include "DMresource.h"
#include "paradyn/src/met/metricExt.h"
#include "paradyn/src/DMthread/MagnifyManager.h"
// Generate a new resource handle. The daemons generate resources id's (handles)
// in the range 0..INT_MAX. If there are conflicts between the handles generated
// by two daemons, paradyn generates a new id in the range INT_MAX..UINT_MAX
inline unsigned newResourceHandle() {
  static unsigned handles = (unsigned) INT_MAX;
  return handles++;
}


//
// used only to construct root.
//
resource::resource()
{
    string temp = "ROOT"; 
    assert(allResources.size()==0);
    if(!allResources.defines(temp)){
        name = temp; 
	res_handle = 0;
        parent = res_handle; 
        suppressSearch = FALSE;
        suppressChildSearch = FALSE;
	suppressMagnify = false;
        abstr = NULL;
        resource *res = this;
	resources[res_handle] = res;
        allResources[name] = res;
    }
}


resource::resource(resourceHandle p_handle, 
		   unsigned tempId,
		   vector<string>& resource_name,
		   string& r_name,
		   string& a, unsigned res_type) 
{
    
    if(!allResources.defines(r_name)){
        type = res_type;
        name = r_name;
	// the daemons generate an id for the resource. If there are no
	// conflicts between this id and the id for other resource, we
	// can keep the daemon id, otherwise we must generate a new
	// id.
	if (resources.defines(tempId))
	   res_handle = newResourceHandle();
	else
	   res_handle = tempId;
        parent = p_handle;
	fullName = resource_name;
	resource *p = resources[parent];
	 
	suppressSearch = p->getSuppressChildren();
	suppressChildSearch = suppressSearch; // check for suppress
					      // of parent's children
	suppressMagnify = false;
        abstr = AMfind(a.string_of());
	resource *res = this;
	allResources[name] = res;
	resources[res_handle] = res;
        p->AddChild(res_handle);
    }
    else assert(0);
}

resource::resource(resourceHandle p_handle, 
		   vector<string>& resource_name,
		   string& r_name,
		   string& a, unsigned res_type) 
{
    
    if(!allResources.defines(r_name)){
        type = res_type;
        name = r_name;
	res_handle = string::hash(name);
	while (resources.defines(res_handle))
	  res_handle = (res_handle+1) % (unsigned)INT_MAX;
        parent = p_handle;
	fullName = resource_name;
	resource *p = resources[parent];
	 
	suppressSearch = p->getSuppressChildren();
	suppressChildSearch = suppressSearch; // check for suppress
					      // of parent's children
	suppressMagnify = false;
        abstr = AMfind(a.string_of());
	resource *res = this;
	allResources[name] = res;
	resources[res_handle] = res;
        p->AddChild(res_handle);
    }
    else assert(0);
}


resource *resource::handle_to_resource(resourceHandle r_handle) {
     // Note: It would be better if this routine returns a reference, and
     // just asserts if the r_handle is bad.  Why?  Because it seems like
     // noone is checking for a NULL return value anyway!
     resource *res;
     if (resources.find(r_handle, res))
       return res;
     else
       return NULL;
}
vector<resourceHandle> *resource::getChildren(){

    vector<resourceHandle> *temp = new vector<resourceHandle>;
    for(unsigned i=0; i < children.size(); i++){
        *temp += (resources[children[i]])->getHandle();      
    }
    return(temp);
}

resourceHandle *resource::findChild(const char *nm) const {
    string temp = nm;
    for(unsigned i=0; i < children.size(); i++){
        if((resources[children[i]])->match(temp)){
	     resourceHandle *h = new resourceHandle;
	     *h = children[i];
	     return(h);
        }
    }
    return(0);  // not found
}


void resource::print()
{
    printf("%s ", name.string_of());
}

void
resource::saveHierarchiesToFile (ofstream& foo)
{
  if (resource::rootResource == NULL) {
    cout << "ROOT IS NULL" << endl;
    return;
  }
  resource *curr = resource::rootResource;
  curr->saveHierarchyToFile(foo);
}  
  
void 
resource::saveHierarchyToFile (ofstream& foo)
{
  resource *curr;
  unsigned childSize = children.size();
  if (childSize == 0) {
    foo << name << endl;
  } else {
    for (unsigned i = 0; i < childSize; i++) {
      curr = resource::handle_to_resource(children[i]);
      curr->saveHierarchyToFile(foo);
    }
  }
}

bool resource::string_to_handle(const string &res, resourceHandle *h) {
    if(allResources.defines(res)){
       resource *temp = allResources[res];
       *h = temp->getHandle();
       return(TRUE);
    }
    else
       return(FALSE);
}

/*
 * Convinence function.
 *
 */

bool resource::isDescendent(resourceHandle child_handle) const {
   resourceHandle root_handle = rootResource->getHandle();
   resourceHandle this_handle = getHandle();
   if (this_handle == child_handle) 
       return FALSE;
   if (this_handle == root_handle) 
       return TRUE;
   while (child_handle != root_handle) {
       if (child_handle == this_handle) {
	  return TRUE;
       } else {
	  child_handle = handle_to_resource(child_handle)->getParent();
       }
   }
   return FALSE;
}

// Convenience function:
bool resource::isDescendantOf(const resource &other) const {
   // NOTE: Should merge with the above routine...

   resourceHandle myHandle = getHandle();
   resourceHandle root_handle = rootResource->getHandle();

   if (myHandle == root_handle)
      // the root node is the descendant of noone.
      return false;

   // Keep moving "myHandle" upwards, until it reaches the root
   // It we see "other.getHandle()" along the way, then we return true.
   do {
      myHandle = handle_to_resource(myHandle)->getParent();
      if (myHandle == other.getHandle())
	 return true;
   } while (myHandle != root_handle);

   return false;
}


/*
 * Do the two resources have the same base?
 * Note, since the there is a common root for all nodes,
 * the test for a common base checks the node below the
 * common root.
 */
bool resource::sameRoot(resourceHandle other) const {
  const resource *myBase=0, *otherBase=0, *temp;

  temp = this;
  resourceHandle root = rootResource->getHandle(); 
  while (temp->getHandle() != root) {
    myBase = temp;
    temp = handle_to_resource(temp->parent);
  }
  temp = handle_to_resource(other);
  while (temp->getHandle() != root) {
    otherBase = temp;
    temp = handle_to_resource(temp->parent);
  }
  if (myBase == otherBase)
    return TRUE;
  else
    return FALSE;
}

const char *resource::getName(resourceHandle h){
    resource *res;
    if (resources.find(h, res))
      return res->getName();
    else
      return 0;
}

const char *resource::getFullName(resourceHandle h){
    resource *res;
    if (resources.find(h, res))
      return res->getFullName();
    else
      return 0;
}

resource *resource::string_to_resource(const string &res) {
    if(allResources.defines(res)){
        return(allResources[res]);
    }
    return 0;
}

// get_lib_constraints: returns true if there is a list of lib constraints
// specified by the mdl exclude_lib option.  If the list has not yet been 
// created, this routine creates the list from the mdl_data list
bool resource::get_lib_constraints(vector<string> &list, vector<unsigned> &flags){
 
    if(!lib_constraints_built) {
        vector<string> temp;
		vector<unsigned> tmp_flags;
	// create list
        if(mdl_get_lib_constraints(temp, tmp_flags)){

	    for(u_int i=0; i < temp.size(); i++) {
                // if the string is of the form "blah/blah" then this
	        // is a function constraint so don't add it to the
	        // list of lib constraints
		char *next = P_strdup((temp[i].string_of()));
		if(next && (!P_strrchr(next, '/'))){
		    lib_constraints += string(next);
		    lib_constraint_flags += tmp_flags[i];
		}
		delete next;
	    }
        }
    }
    for(u_int i=0; i < lib_constraints.size(); i++){
            list += lib_constraints[i];
			flags += lib_constraint_flags[i];
    }
    lib_constraints_built = true;
    return lib_constraints.size();
}


// get_func_constraints: returns true if there is a list of func constraints
// specified by the mdl exclude_func option.  If the list has not yet been 
// created, this routine creates the list from the mdl_data list
bool resource::get_func_constraints(vector< vector<string> > &list, vector<unsigned> &flags){
 
    if(!func_constraints_built) {
        vector< string > temp;
		vector<unsigned> tmp_flags;
	// create list
        if(mdl_get_lib_constraints(temp, tmp_flags)){
	    for(u_int i=0; i < temp.size(); i++){
                // if the string is of the form "blah/blah" then this
	        // is a function constraint so add it to the list 
		char *next = P_strdup((temp[i].string_of()));
		if(next && (P_strrchr(next, '/'))) {
		  u_int where = 0;
		  u_int prev_where = where;
		  for(u_int j=0; j< temp[i].length();j++){
                    if(next[j] == '/'){
		       prev_where = where;
		       where = j+1; 
		    }
		  }
		  assert(where < temp[i].length());
		  assert(where > prev_where);
		  vector<string> func_consts;
		  // module name
		  u_int size = where-prev_where;
		  char *temp_str = new char[size]; 
	          if(P_strncpy(temp_str,&(next[prev_where]),size-1)){
		    temp_str[size-1] = '\0';
		    string blah(temp_str);
		    func_consts += blah; 

		    // function name
		    func_consts += string(&(next[where])); 
		    assert(func_consts.size() == 2);
		    func_constraints += func_consts; 

			// constraint flags
			func_constraint_flags += tmp_flags[i];
		  }
	          delete [] temp_str;	
                }
	        if(next) delete next;
	    }
        }
    }
    for(u_int i=0; i < func_constraints.size(); i++){
            list += func_constraints[i];
			flags += func_constraint_flags[i];
    }
    func_constraints_built = true;

    return func_constraints.size();
}

int DMresourceListNameCompare(const void *n1, const void *n2){
    
    const string *s1 = (const string*)n1, *s2 = (const string*)n2;
    if(*s1 > *s2)
       return(1);
    if(*s1 == *s2)
       return(0);
    else
       return(-1);

}

string DMcreateRLname(const vector<resourceHandle> &res){
    // create a unique name
    string temp;
    resource *next;

    vector <string> sorted_names;

    for(unsigned i=0; i < res.size(); i++){
	next = resource::handle_to_resource(res[i]);
	sorted_names += next->getFullName();
    }
    sorted_names.sort(DMresourceListNameCompare);

    for(unsigned j=0; j < (res.size() - 1); j++){
	temp += sorted_names[j].string_of();
	temp += ",";
    }
    if(res.size() > 0){
	temp += sorted_names[(res.size()-1)].string_of();
    }
    return(temp);
}

resourceList::resourceList(const vector<resourceHandle> &res){
    // create a unique name
    string temp = DMcreateRLname(res);

    //cerr << "resourceList::resourceList(const vector<resourceHandle> &res)"
    // << " called" << endl;
    //cerr << " temp (name string) = " << temp << endl;

    if(!allFoci.defines(temp)){
        id = foci.size();
	resourceList *rl = this;
        allFoci[temp] = rl;
        fullName = temp;
        foci += rl;

        // create elements vector 
        for(unsigned i=0; i < res.size(); i++){
	    resource *r = resource::handle_to_resource(res[i]);
	    if(r){
	        elements += r;
		if(r->getSuppress()){
                    suppressed = true;
		}
	    }
    } }
    else {
        printf("ERROR: this resourceList already created: %s\n",temp.string_of());
    }
}

// this should be called with strings of fullNames for resources
// ex.  "/Procedure/blah.c/foo"  rather than "foo"
resourceList::resourceList(const vector<string> &names){
    // create a unique name
    unsigned size = names.size();
    string temp;
    for(unsigned i=0; i < size; i++){
       temp += names[i]; 
       if(i < (size-1)){
	   temp += ",";
       }
    }
    // see if this resourceList has been created already, if not add it
    if(!allFoci.defines(temp)){
        id = foci.size();
        resourceList *rl = this;
        allFoci[temp] = rl;
        fullName = temp;
        foci += rl;
        // create elements vector 
        for(unsigned j=0; j < size; j++){
	    resource *r = resource::string_to_resource(names[j]);
	    if(r){
	        elements += r;
		if(r->getSuppress()){
                    suppressed = true;
		}
	    }
        } 
    }
    else {
        printf("ERROR: this resourceList already created: %s\n",temp.string_of());
    }
}


void resourceList::print()
{
    printf("{");
    for (unsigned i=0; i < elements.size(); i++) {
	if (i) printf(" ");
	printf("{");
	elements[i]->print();
	printf("}");
    }
    printf("}");
}

bool resourceList::convertToStringList(vector< vector<string> > &fs) {
    for (unsigned i=0; i < elements.size(); i++)
        fs += elements[i]->getParts();
    return true;
}

bool resourceList::convertToIDList(vector<resourceHandle> &fs) {
    for (unsigned i=0; i < elements.size(); i++){
        fs += elements[i]->getHandle();
    }
    return true;
}

bool resourceList::convertToIDList(resourceListHandle rh,
				   vector<resourceHandle> &rl){

    for(u_int i=0; i < foci.size(); i++){
        if(rh == foci[i]->getHandle()){
	    return(foci[i]->convertToIDList(rl));
    }}
    return false;
}

// This routine returns a list of foci which are the result of combining
// each child of resource rh with the remaining resources that make up the
// focus, otherwise it returns 0
vector<rlNameId> *resourceList::magnify(resourceHandle rh, magnifyType type){
    vector<resourceHandle> *children;
    vector<rlNameId> *return_list;

    // supported magnify types....
    assert(type == OriginalSearch || type == CallGraphSearch);

    // check to see if rh is a component of this resourceList
    unsigned rIndex = elements.size();
    for(unsigned i=0; i < elements.size(); i++){
        if(rh == elements[i]->getHandle()){
            rIndex = i;
	    break;
	}
    }
    if(rIndex < elements.size()){
      return_list = new vector<rlNameId>;

      // calls elements[rIndex]->getChildren or CallGraph::getChildren
      //  depending on the magnify type and the characteristics of the 
      //  resource....

#ifdef PCDEBUG
      printf("Calling magnifymanager::getChildren\n");
#endif
      
      children = MagnifyManager::getChildren(elements[rIndex], type);

      if(children->size()){ // for each child create a new focus
	vector<resourceHandle> new_focus; 
	for(unsigned i=0; i < elements.size(); i++){
	  new_focus += (elements[i])->getHandle();
	}
	rlNameId temp;
	for(unsigned j=0; j < children->size(); j++){
	  // check to see if this child can be magnified
	  // if so, create a new focus with this child
	  resource *child_res = resource::handle_to_resource((*children)[j]);
	  if(child_res && !(child_res->isMagnifySuppressed())){
	      new_focus[rIndex] = (*children)[j];
	      temp.id = resourceList::getResourceList(new_focus);
	      temp.res_name = resource::getName((*children)[j]);
	      *return_list += temp; 
	  }
	}
	delete children;
	return return_list;
      }
    }
    return 0;
}

// if resource rh is a decendent of a component of the focus, return a new
// focus consisting of rh replaced with it's corresponding entry, 
// otherwise return 0 
//
resourceListHandle *resourceList::constrain(resourceHandle rh){

    unsigned rIndex = elements.size(); 
    for(unsigned i=0; i < elements.size(); i++){
        if(elements[i]->isDescendent(rh)){
	    rIndex = i;
            break;
    }}
    if(rIndex < elements.size()){
	vector<resourceHandle> new_focus; 
	for(unsigned j=0; j < elements.size(); j++){
            new_focus += (elements[j])->getHandle();
	}
	new_focus[rIndex] = rh;
	resourceListHandle *new_handle = new resourceListHandle;
	*new_handle = this->getResourceList(new_focus);
	return new_handle;
    }
    return 0;
}

#ifdef ndef
// This routine returns a list of foci each of which is the result of combining
// each child of one of the resources with the remaining resource components of
// the focus. this is iterated over all resources in the focus.
// returns 0 if all resources in the focus have no children
vector<resourceListHandle> *resourceList::magnify(magnifyType type){
    
    vector<resourceListHandle> *return_list = new vector<resourceListHandle>;
    for(unsigned i=0; i < elements.size(); i++){
	vector<resourceListHandle> *next = 
				   this->magnify((elements[i])->getHandle(), type);
	if(next) *return_list += *next;
	delete next;
    }
    if(return_list->size()) return return_list;
    return 0;
}
#endif

// This routine returns a list of foci each of which is the result of combining
// each child of one of the resources with the remaining resource components of
// the focus. this is iterated over all resources in the focus.
// returns 0 if all resources in the focus have no children
vector<rlNameId> *resourceList::magnify(magnifyType type){
    
    vector<rlNameId> *return_list = new vector<rlNameId>;
    for(unsigned i=0; i < elements.size(); i++){
	vector<rlNameId> *next = 
	                 this->magnify((elements[i])->getHandle(), type);
        if(next) {
	  for (unsigned j=0; j < next->size(); j++){
	    *return_list += (*next)[j];
	  }
	  delete next;
	}
      }
    if(return_list->size()) return return_list;

    // memory leak, original was
    // return 0;
    // -matt
    delete return_list;
    return NULL;
}


const char *resourceList::getName(resourceListHandle rh){

    if(rh < foci.size()){
        resourceList *rl = foci[rh];
        return(rl->getName());
    }
    return(NULL);
}


bool resourceList::getMachineNameReferredTo(string &machName) const {
   // If this focus is specific to some machine, then fill in "machName" and return
   // true.  Else, leave "machName" alone and return false.
   // What does it mean for a focus to be specific to a machine?
   // For one, if the focus is a descendant of a machine, then it's obvious.
   // If the focus is a descendant of a process, then we can probably find a specific
   // machine to which it's referring, too.
   // NOTE: If this routine gets confused or isn't sure whether the resource is
   // specific to a machine, it returns false.
   
   // Step 1: Obtain the resources for /Machine and /Process
   // Since these are expensive operations (the string constructor is called,
   // which in turn calls new[]), we only do them once.
   static resource *machine_resource_ptr = NULL; // NULL --> not yet defined
   static resource *process_resource_ptr = NULL; // NULL --> not yet defined

   if (machine_resource_ptr == NULL) {
      machine_resource_ptr = resource::string_to_resource("/Machine");
      if (machine_resource_ptr == NULL) {
         cout << "getMachineNameReferredTo(): couldn't find /Machine" << endl;
         return false;
      }
   }

   if (process_resource_ptr == NULL) {
      process_resource_ptr = resource::string_to_resource("/Process");
      if (process_resource_ptr == NULL) {
	 cout << "getMachineNameReferredTo(): couldn't find /Process" << endl;
	 return false;
      }
   }

   assert(machine_resource_ptr);
   assert(process_resource_ptr);
   const resource &machineResource = *machine_resource_ptr;
   const resource &processResource = *process_resource_ptr;

   for (unsigned hierarchy=0; hierarchy < elements.size(); hierarchy++) {
      const resource *the_resource_ptr = elements[hierarchy];
      const resource &theResource = *the_resource_ptr;

      // Is "theResource" a descendant of "/Machine"?
      if (theResource.isDescendantOf(machineResource)) {
         // bingo.  Now check out the resource's components.  The machine name
         // should be in the 2d component, and the first component should be "Machine".
	 // (For example, the resource "/Machine/goat" has 2 components)
	 const vector<string> &components = theResource.getParts();

         // The following line is not fast; calls string's constructor which calls
	 // malloc.  But it's really just an assert, so we could get rid of it for
	 // speed.
         if (components[0] != "Machine") {
            // I am confused; I expected "Machine"
	    cout << "getMachineNameReferredTo: expected Machine; found "
                 << components[0] << endl;
	    return false;
         }
	 if (components.size() < 2) {
            // I am confused; I expected something below "Machine"
	    cout << "getMachineNameReferredTo: nothing below 'Machine'" << endl;
	    return false;
	 }
	 if (components.size() > 2) {
            // currently, there is only one level below "Machine"
	    // Maybe in the future we can have stuff like "/Machine/cluster1/goat"
	    // But for now this acts as a nice assert (in that if the following error
            // msg is ever seen, then we need to rethink how we extract the machine
	    // name)
	    cout << "getMachineNameReferredTo: too much below 'Machine'" << endl;
	    return false;
	 }

	 // success!
	 machName = components[1];
	 return true;
      }
      else if (theResource.isDescendantOf(processResource)) {
         // bingo.  Now check out the resource's components.
         // For example, if the resource is "/Process/bubba.pd{9984_goat}"
         // then we extract the machine name from the 2d component.
	 const vector<string> &components = theResource.getParts();

         // The following line is not fast; calls string's constructor which calls
	 // malloc.  But it's really just an assert, so we could get rid of it for
	 // speed.
	 if (components[0] != "Process") {
	    // I am confused; I expected "Process"
	    cout << "getMachineNameReferredTo: expected Process; found "
	         << components[0] << endl;
	    return false;
	 }
	 if (components.size() < 2) {
            // I am confused; I expected something below "Process"
	    cout << "getMachineNameReferredTo: nothing below 'Process'" << endl;
	    return false;
	 }
	 if (components.size() > 3) {
            // currently, there is only one level below "Process"
	    // Maybe in the future we can have stuff like "/Process/cluster2/process1"
	    // But for now this acts as a nice assert (in that if the error msg is ever
	    // seen then we know that we need to rethink how we extract machine names
	    // from processes).
	    cout << "getMachineNameReferredTo: too much below 'Process'" << endl;
	    return false;
	 }

	 // Now all that's left to do is to extract the machine name, given the process.
	 // Currently, processes are of the form:
	 // <procname>{<pid>_<machname>}
	 // I would use one sscanf except for the well-known problems that it has
	 // (it can overflow buffers).  So, we parse manually.
	 const char *ptr = components[1].string_of();
	 const char *ptr1 = strchr(ptr, '{');
	 if (ptr1 == NULL) {
	    cout << "getMachineNameReferredTo: expected { in the proc name" << endl;
	    return false;
	 }
	 const char *ptr2 = strchr(ptr1, '_');
	 if (ptr2 == NULL) {
	    cout << "getMachineNameReferredTo: expected _ in the proc name" << endl;
	    return false;
	 }
	 ptr2++;
	 if (strlen(ptr2) < 2) {
            // expected at least 1 char for machine name, plus 1 char for closing '}'
	    cout << "getMachineNameReferredTo: blank machine name?" << endl;
	    return false;
	 }

	 // The last character should be '}'; overwrite it with a '\0'.
	 // Unfortunately, we cannot write to the string without messing
	 // up the resource.  So, we play with a _copy_ of the string.
	 if (ptr2[strlen(ptr2)-1] != '}') {
	    cout << "getMachineNameReferredTo: expected }" << endl;
	    return false;
	 }

	 // We're basically done.  Return the string pointed to by ptr2
         // _except_ the last character, which is '}' (so we use the string constructor
	 // which copies only part of a char*)
	 machName = string(ptr2, strlen(ptr2)-1); // not a fast operation; calls malloc
	 return true;
      }
   }

   return false;
}

vector<resourceHandle> *resourceList::getResourceHandles(resourceListHandle h){
    resourceList *focus = getFocus(h);
    if(focus){
        vector<resourceHandle> *handles = new vector<resourceHandle>;
        for(unsigned i=0; i < focus->elements.size(); i++){
	    resource *part = focus->elements[i];
            *handles += part->getHandle(); 
	}
	return(handles);
    }
    return(NULL);
}

const resourceListHandle *resourceList::find(const string &name){

    if(allFoci.defines(name)){
        resourceList *res_list = allFoci[name]; 
	const resourceListHandle *h = &res_list->id;
	return(h);
    }
    return 0;


}

resourceListHandle resourceList::getResourceList(
				const vector<resourceHandle>& h){

    // does this resourceList already exist?
    string temp = DMcreateRLname(h);
    if(allFoci.defines(temp)){
	resourceList *rl = allFoci[temp];
        return(rl->getHandle());
    }
    // create a new resourceList
    resourceList *res = new resourceList(h);
    assert(res);
    return(res->getHandle());
}

resourceList *resourceList::findRL(const char *name){
    string temp = name;
    if(allFoci.defines(name)){
        return allFoci[name];
    }
    return NULL;
}

void printAllResources() {
    vector<resource *>allRes = resource::resources.values();
    for(unsigned i=0; i < allRes.size(); i++){
        cout << "{";
        (allRes[i])->print();
	cout << "}" << endl;
    }
}
