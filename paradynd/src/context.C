/*
 * Copyright (c) 1996 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

/* $Id: context.C,v 1.62 2000/03/12 23:31:01 hollings Exp $ */

#include "dyninstAPI/src/symtab.h"
#include "dyninstAPI/src/pdThread.h"
#include "dyninstAPI/src/process.h"
#include "rtinst/h/rtinst.h"
#include "rtinst/h/trace.h"
#include "dyninstAPI/src/dyninst.h"
#include "dyninstAPI/src/dyninstP.h"
#include "dyninstAPI/src/inst.h"
#include "dyninstAPI/src/instP.h"
#include "dyninstAPI/src/ast.h"
#include "dyninstAPI/src/util.h"
#include "paradynd/src/metric.h"
#include "paradynd/src/perfStream.h"
#include "dyninstAPI/src/os.h"
#include "dyninstAPI/src/showerror.h"
#include "paradynd/src/costmetrics.h"
#include "paradynd/src/hashTable.h"

// The following were defined in process.C
extern debug_ostream attach_cerr;
extern debug_ostream inferiorrpc_cerr;
extern debug_ostream shmsample_cerr;
extern debug_ostream forkexec_cerr;
extern debug_ostream metric_cerr;
extern debug_ostream signal_cerr;

extern vector<process*> processVec;

/*
 * find out if we have an application defined
 */
bool applicationDefined()
{
    if (processVec.size()) {
	return(true);
    } else {
	return(false);
    }
}

extern process *findProcess(int); // should become a static method of class process

//timeStamp getCurrentTime(bool);

#if defined(SHM_SAMPLING) && defined(MT_THREAD)

void createThread(traceThread *fr) {
    process *proc=NULL;
    assert(fr);
    proc = findProcess(fr->ppid);
    if (!(proc && proc->rid)) // 6/2/99 zhichen, a weird situation
      return ;                // when a threaded-process forks

    // creating new thread
    pdThread *thr = proc->createThread(fr->tid, fr->pos, fr->stack_addr, 
      fr->start_pc, fr->resumestate_p, fr->context==FLAG_SELF);
    assert(thr);

    // computing resource id
    string buffer;
    string pretty_name = string(thr->get_start_func()->prettyName().string_of()) ;
    buffer = string("thr_")+string(fr->tid)+string("{")+pretty_name+string("}");
    resource *rid;
    rid = resource::newResource(proc->rid, (void *)thr, nullString, 
				buffer, 0.0, "", MDL_T_STRING, true);
    thr->update_rid(rid);        
}

//
// The thread reported from DYNINSTinit when using attaching 
//
void updateThreadId(traceThread *fr) {
  //static bool firstTime=true;
  //assert(firstTime); // this routine should only execute once! - naim
  //firstTime=false;
  process *proc = findProcess(fr->ppid);
  assert(proc);
  pdThread *thr = proc->threads[0];
  assert(thr);
  string buffer;
  resource *rid;
  if (fr->context == FLAG_ATTACH ) {
    proc->updateThread(thr, fr->tid, fr->pos, fr->stack_addr, fr->start_pc, fr->resumestate_p) ;
cerr << "updateThreadId, context == FLAG_ATTACH" << endl ;
    // computing resource id
    string pretty_name = string(thr->get_start_func()->prettyName().string_of()) ;
    buffer = string("thr_")+string(fr->tid)+string("{")+pretty_name+string("}");
    rid = resource::newResource(proc->rid, (void *)thr, nullString, 
				  buffer, 0.0, "", MDL_T_STRING, true);
    thr->update_rid(rid);        
  } else {
cerr << "updateThreadId, context == FLAG_INIT" << endl ;
    buffer = string("thr_") + string(fr->tid) + string("{main}") ;
    rid = resource::newResource(proc->rid, (void *)thr, nullString, 
			      buffer, 0.0, "", MDL_T_STRING, true);  

    // updating main thread
    proc->updateThread(thr, fr->tid, fr->pos, fr->resumestate_p, rid);
  }
  //sprintf(errorLine, "*****updateThreadId, tid=%d, pos=%d, stack=0x%x, startpc=0x%x, resumestat=0x%x\n", fr->tid, fr->pos, fr->stack_addr, fr->start_pc, fr->resumestate_p) ;
  //logLine(errorLine) ;
}

void deleteThread(traceThread *fr)
{
    process *proc=NULL;

    assert(fr);
    proc = findProcess(fr->ppid);
    assert(proc && proc->rid);

    // deleting thread
    proc->deleteThread(fr->tid);

    // deleting resource id
    // how do we delete a resource id? - naim
}

#endif

unsigned instInstancePtrHash(instInstance * const &ptr) {
   // would be a static fn but for now aix.C needs it.
   unsigned addr = (unsigned)(Address)ptr;
   return addrHash16(addr); // util.h
}

void forkProcess(int pid, int ppid, int trace_fd
#ifdef SHM_SAMPLING
		 ,key_t theKey,
		 void *applAttachedAtPtr
#endif
		 ) {
   process *parentProc = findProcess(ppid);
   if (!parentProc) {
      logLine("Error in forkProcess: could not find parent process\n");
      return;
   }

#ifdef FORK_EXEC_DEBUG
    timeStamp forkTime = getCurrentTime(false);
#endif

   dictionary_hash<instInstance*, instInstance*> map(instInstancePtrHash);
      // filled in by process::forkProcess() call.  The map is as follows: for each
      // instInstance in the parent process, it gives us the instInstance in the child
      // child process.

#ifdef SHM_SAMPLING
    process *childProc = process::forkProcess(parentProc, (pid_t)pid, map, trace_fd,
					      theKey, applAttachedAtPtr);
#else
    process *childProc = process::forkProcess(parentProc, (pid_t)pid, map, trace_fd);
#endif

   // For each mi with a component in parentProc, copy it to the child process --- if
   // the mi isn't refined to a specific process (i.e. is for 'any process')
   // NOTE: It's easy to not copy data items (timers, ctrs) that don't belong in the
   //       child.  But for trampolines, it's tricky, since the fork() syscall will
   //       copy all code whether we like it or not (except on AIX).  Since the
   //       meta-data for the conventional inferior heap has already been copied by the
   //       fork-ctor, when we detect code that shouldn't have been copied, we manually
   //       delete it with deleteInst().  "map" is helpful in this context.
   metricDefinitionNode::handleFork(parentProc, childProc, map);

#ifdef SHM_SAMPLING
   // The following routines perform some assertion checks.
   childProc->getTable().forkHasCompleted();
#endif

#ifdef FORK_EXEC_DEBUG
   cerr << "Fork process took " << (getCurrentTime(false)-forkTime) << " secs" << endl;
#endif

   // Here is where we (used to) continue the parent process...who has been waiting
   // patiently at a DYNINSTbreakPoint() since the beginning of DYNINSTfork() while all
   // this hubbub was going on.  But we can't issue the continueProc().  Why not?
   // Because it's quite possible that the signal delivered to paradynd by the
   // DYNINSTbreakPoint() hasn't yet been processed (yes, this happens in practice), so
   // paradynd still thinks that parentProc's status is running.  What's the
   // solution?  We create a stupid new field in the process structure that, when true,
   // tells paradynd that when the next SIGSTOP is delivered, to continue the process.
   // On the other hand, if parentProc's status is stopped, then we go ahead and issue
   // the continueProc now.  --ari

//   if (parentProc->status() == running)
//      parentProc->continueAfterNextStop();
//   else
//      if (!parentProc->continueProc())
//         assert(false);
}

int addProcess(vector<string> &argv, vector<string> &envp, string dir) {
    process *proc = createProcess(argv[0], argv, envp, dir, 0, 1, 2);

    if (proc) {
      return(proc->getPid());
    } else {
      return(-1);
    }
}

#ifdef notdef
bool addDataSource(char *name, char *machine,
    char *login, char *command, int argc, char *argv[])
{
    P_abort();
    return(false);
}
#endif

bool startApplication()
{
    continueAllProcesses();
    return(false);
}

// TODO use timers here
timeStamp startPause = 0.0;

// total processor time the application has been paused.
// so for a multi-processor system this should be processor * time.
timeStamp elapsedPauseTime = 0.0;

static bool appPause = true;

bool markApplicationPaused()
{
  if (!appPause) {
    // get the time when we paused it.
    startPause = getCurrentTime(false);
    // sprintf(errorLine, "paused at %f\n", startPause);
    // logLine(errorLine);
    appPause = true;
    return true;
  } else 
    return false;
}

bool isApplicationPaused()
{
  return appPause;
}

bool continueAllProcesses()
{
    unsigned p_size = processVec.size();
    for (unsigned u=0; u<p_size; u++) {
       process *p = processVec[u];
       if (p != NULL && p->status() != running) {
	 if (!processVec[u]->continueProc()) {
	   sprintf(errorLine,"WARNING: cannot continue process %d\n",processVec[u]->getPid());
	   cerr << errorLine << endl;
	 }
       }
    }

    statusLine("application running");

    if (!appPause) return(false);
    appPause = false;

    if (!firstRecordTime) return (false);

    if (startPause > 0.0) 
      elapsedPauseTime += (getCurrentTime(false) - startPause);

    // sprintf(errorLine, "continued at %f\n", getCurrentTime(false));
    // logLine(errorLine);

    return(false);
}

bool pauseAllProcesses()
{
    bool changed = markApplicationPaused();

    unsigned p_size = processVec.size();
    for (unsigned u=0; u<p_size; u++) {
       process *p = processVec[u];
       if (p != NULL && p->status() == running)
         processVec[u]->pause();
    }

    if (changed)
      statusLine("application paused");

    return(changed);
}

void processNewTSConnection(int tracesocket_fd) {
   // either a forked process or one created via attach is trying to get a new
   // tracestream connection.  accept() the new connection, then do some processing.
   // There is no need to restrict this for forked and attached processes --mjrg

   int fd = RPC_getConnect(tracesocket_fd); // accept()
      // will become traceLink of new process
   assert(fd >= 0);

   unsigned cookie;
   if (sizeof(cookie) != read(fd, &cookie, sizeof(cookie)))
      assert(false);

   bool calledFromFork = false;
   bool calledFromAttach = false;

   const unsigned cookie_fork   = 0x11111111;
   const unsigned cookie_attach = 0x22222222;

   calledFromFork   = (cookie == cookie_fork);
   calledFromAttach = (cookie == cookie_attach);

   string str;
   if (calledFromFork)
      str = string("getting new connection from forked process");
   else
      str = string("getting new connection from attached process");
   statusLine(str.string_of());

   int pid;
   if (sizeof(pid) != read(fd, &pid, sizeof(pid)))
      assert(false);

   int ppid;
   if (sizeof(ppid) != read(fd, &ppid, sizeof(ppid)))
      assert(false);

#ifdef SHM_SAMPLING
   key_t theKey;
   if (sizeof(theKey) != read(fd, &theKey, sizeof(theKey)))
      assert(false);

   uint32_t ptr_size;
   if (sizeof(ptr_size) != read(fd, &ptr_size, sizeof(ptr_size)))
      assert(false);

   void *applAttachedAtPtr = NULL;
   char *ptr_dst = (char *)&applAttachedAtPtr;
   if (sizeof(void *) > ptr_size) {
      // adjust for pointer size mismatch
      ptr_dst += sizeof(void *) - sizeof(int32_t);
   }
   if (ptr_size != read(fd, ptr_dst, ptr_size))
      assert(false);
#endif

   process *curr = NULL;

   if (calledFromFork) {
      // the following will (1) call fork ctor (2) call metricDefinitionNode::handleFork
      // (3) continue the parent process, who has been waiting to avoid race conditions.
#ifdef SHM_SAMPLING
      forkProcess(pid, ppid, fd, theKey, applAttachedAtPtr);
#else
      forkProcess(pid, ppid, fd);
#endif

      curr = findProcess(pid);
      assert(curr);

      // continue process...the next thing the process will do is call
      // DYNINSTinit(-1, -1, -1)
      string str = string("running DYNINSTinit() for fork child pid ") + string(pid);
	  forkexec_cerr << str << endl;
      statusLine(str.string_of());

	  if( curr->status() == running )
	  {
//#if defined(i386_unknown_linux2_0)
		  curr->continueAfterNextStop();
//#endif
	  }
	  else if (!curr->continueProc())
		  assert(false);

#if defined(rs6000_ibm_aix4_1)
      // HACK to compensate for AIX goofiness: as soon as we call continueProc() above
      // (and not before!), a SIGTRAP appears to materialize out of thin air, stopping
      // the child process.  Thus, DYNINSTinit() won't run unless we issue an explicit
      // continue.  (Actually, there may be a semi-legit explanation.  It seems that on
      // non-solaris platforms, including sunos and aix, if a sigstop is sent and not
      // handled -- i.e. if we just leave the application in a paused state, without
      // continuing -- then the sigstop will be sent over and over again, nonstop, until
      // the application is continued.  So perhaps the sigtrap we see now was present all
      // along, but we never knew it because waitpid in the main loop kept returning
      // sigstops.  --ari)

      int wait_status;
      int wait_result = waitpid(curr->getPid(), &wait_status, WNOHANG);
      if (wait_result > 0) {
	 bool was_stopped = WIFSTOPPED(wait_status);
	 if (was_stopped) {
	    int sig = WSTOPSIG(wait_status);
	    if (sig == 5)  { // sigtrap
	       curr->status_ = stopped;
	       if (!curr->continueProc())
		  assert(false);
	    }
	 }
      }
#elif defined(i386_unknown_linux2_0)
	  int wait_status;
	  int wait_result = waitpid( curr->getPid(), &wait_status, WUNTRACED );
	  if( wait_result > 0 && WIFSTOPPED(wait_status) )
	  {
		  int sig = WSTOPSIG(wait_status);
		  forkexec_cerr << "Extra check: stopped on sig " << sig << endl;
		  if (sig == SIGTRAP || sig == SIGSTOP)
		  {
			  curr->status_ = stopped;
			  if (!curr->continueProc())
				  assert(false);
		  }
	  }
#endif      
   }

   else {
      // This routine gets called when the attached process is in
      // the middle of running DYNINSTinit.
      curr = findProcess(pid);
      assert(curr);
      curr->traceLink = fd;
      statusLine("ready");
   }

}
