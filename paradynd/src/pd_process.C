/*
 * Copyright (c) 1996-2004 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as "Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

// $Id: pd_process.C,v
#include "paradynd/src/pd_process.h"
#include "paradynd/src/pd_thread.h"
#include "paradynd/src/init.h"
#include "paradynd/src/metricFocusNode.h"
#include "paradynd/src/processMgr.h"
#include "paradynd/src/costmetrics.h"
#include "paradynd/src/perfStream.h"
#include "paradynd/src/pd_image.h"
#include "paradynd/src/pd_module.h" 

#include "dyninstAPI/h/BPatch.h"
#if defined(i386_unknown_nt4_0)
#include <Windows.h>
#endif

#include "paradynd/src/debug.h"

#include "paradynd/src/mdld.h"

#include "common/h/timing.h"
extern void setFirstRecordTime(const timeStamp &ts);
extern bool isInitFirstRecordTime();

// Set in main.C
extern int termWin_port;
extern pdstring pd_machine;
extern PDSOCKET connect_Svr(pdstring machine,int port);
extern pdRPC *tp;
extern MRN::Stream * defaultStream;
extern pdvector<pdinstMapping*> initialRequestsPARADYN; 
extern unsigned SHARED_SEGMENT_SIZE;

// Exec callback
extern void pd_execCallback(pd_process *proc);

pdvector<pdstring> pd_process::arg_list;
pdstring pd_process::defaultParadynRTname;
pdstring pd_process::pdFlavor;
pdstring pd_process::programName;

extern resource *machineResource;

extern pdstring formatLibParadynName(pdstring orig);

void addLibraryCallback(BPatch_process *thr, BPatch_module *mod, bool load)
{
  if (!mod) {
    //fprintf(stderr, "%s[%d]:  addModuleCallback called w/out module!\n",
    //        __FILE__, __LINE__);
    return;
  }

  BPatch_process *appProc = NULL;
  pd_process *parent_proc = NULL;
  for (unsigned int i = 0; i < pd_image::all_pd_images.size(); ++i) {
    parent_proc = pd_image::all_pd_images[i]->getParentProc();
    appProc = parent_proc->get_dyn_process();
    if (appProc  == thr) {
      break; 
    }
    parent_proc = NULL;
  }

  if (!parent_proc) {
    fprintf(stderr, "%s[%d]:  Could not find parent process for new module\n",
            __FILE__, __LINE__);
    return;
   }

  pd_image *img = parent_proc->getImage();

  if (!img) {
       fprintf(stderr, "%s[%d]:  this should never happen!\n", __FILE__, __LINE__);
       return;
  }

  if (load) {

    if (img->hasModule(mod)) {
      fprintf(stderr, "%s[%d]:  WARN:  addModule ignoring duplicate!\n",
              __FILE__, __LINE__);
    }
    else {
      img->addModule(mod);
      return;
    }
  }
  else {
    fprintf(stderr, "%s[%d]:  Non-load call of BPatchDynLibraryCallback!\n",
            __FILE__, __LINE__);
    fprintf(stderr, "%s[%d]:  Not anticipated, not fatal, but FIXME.\n",
            __FILE__, __LINE__);
  }
}

// Global "create a new pd_process object" functions

pd_process *pd_createProcess(pdvector<pdstring> &argv, pdstring dir)
{

#if !defined(i386_unknown_nt4_0)
    if (termWin_port == -1)
        return NULL;
    
    PDSOCKET stdout_fd = INVALID_PDSOCKET;	
    if ((stdout_fd = connect_Svr(pd_machine,termWin_port)) == INVALID_PDSOCKET) {
        return NULL;
    }
    if (write(stdout_fd,"from_app\n",strlen("from_app\n")) <= 0) {
        CLOSEPDSOCKET(stdout_fd);
        return NULL;
    }
#endif
    
    pd_process *proc;
#if defined(os_windows)
    proc = new pd_process(argv[0], argv, dir, 0, 1, 2);
#else
    proc = new pd_process(argv[0], argv, dir, 0, stdout_fd, 2);
#endif
    if ( (proc == NULL) || (proc->get_dyn_process() == NULL) ) {
#if !defined(os_windows)
        CLOSEPDSOCKET(stdout_fd);
#endif
        return NULL;
    }
    
    //Add to process manager
    getProcMgr().addProcess(proc);
    
    // Load the paradyn runtime lib
    if (!proc->getSharedMemMgr()->initialize()) {
        fprintf(stderr, "%s[%d]:  failed to init shared mem mgr, fatal...\n", __FILE__, __LINE__);
        return NULL;
    }
    
    proc->loadParadynLib(pd_process::create_load);
    
    // Run necessary initialization
    proc->init();
    
    if(!costMetric::addProcessToAll(proc->get_dyn_process()))
        assert(false);
    
    return proc;
}

pd_process *pd_attachProcess(const pdstring &progpath, int pid)
{ 

	pd_process *proc = new pd_process(progpath, pid);
	
	if (!proc || !proc->get_dyn_process())
		return NULL;

	if (!proc->getSharedMemMgr()->initialize()) 
		{
			fprintf(stderr, "%s[%d]:  failed to init shared mem mgr, fatal...\n", __FILE__, __LINE__);
			return NULL;
		}
	
	proc->loadParadynLib(pd_process::attach_load);
	
	if (!costMetric::addProcessToAll(proc->get_dyn_process()))
		assert(false);
	
	getProcMgr().addProcess(proc);
	proc->init();
	
	pdstring buffer = pdstring("PID=") + pdstring(itos(proc->getPid()));
	buffer += pdstring(", ready");
	pdstatusLine(buffer.c_str());
	
	return proc;
}

extern BPatch_process *MPI_proc;

pd_process *pd_attachToCreatedProcess(const pdstring &/*progpath*/, 
                                      int /*pid*/) {
    // This has atrophied and needs to be fixed;
    // instead of horrible behavior I'm going to have it
    // break.
    
    // We need a Dyninst-level attach to created mechanism...

    return NULL;
}

void pd_process::init()
{
	static bool has_mt_resource_heirarchies_been_defined = false;
	pdstring buffer = pdstring("PID=") + pdstring(itos(getPid()));
	buffer += pdstring(", initializing daemon-side data");
	pdstatusLine(buffer.c_str());
	
	theVariableMgr = new variableMgr(this, getSharedMemMgr(),
																	 maxNumberOfThreads());
	buffer = pdstring("PID=") + pdstring(itos(getPid()));
	buffer += pdstring(", posting call graph information");
	pdstatusLine(buffer.c_str());
	

	if(multithread_capable() && !has_mt_resource_heirarchies_been_defined) {
        resource::newResource(syncRoot, NULL, nullString, "Mutex", 
                              timeStamp::ts1970(), "", 
                              CategoryResourceType,
                              MDL_T_STRING,
                              false);
        resource::newResource(syncRoot, NULL, nullString, "RwLock", 
                              timeStamp::ts1970(), "",
                              CategoryResourceType,
                              MDL_T_STRING,
                              false);
        resource::newResource(syncRoot, NULL, nullString, "CondVar", 
                              timeStamp::ts1970(), "",
                              CategoryResourceType,
                              MDL_T_STRING,
                              false);
        has_mt_resource_heirarchies_been_defined = true;
    }

    findThreads();
}


// Creation constructor
pd_process::pd_process(const pdstring argv0, pdvector<pdstring> &argv,
                       const pdstring dir, int stdin_fd, int stdout_fd,
                       int stderr_fd) 
    : monitorFunc(NULL),
      os_handle(0),
      numOfActCounters_is(0), numOfActProcTimers_is(0),
      numOfActWallTimers_is(0), 
      cpuTimeMgr(NULL),
#ifdef PAPI
      papi(NULL),
#endif
      paradynRTState(libUnloaded),
      cumulativeObsCost(0),
      lastObsCostLow(0),
      inExec(false),
      canReportResources_(false)
{
    
    if (!MPI_proc) {
        if ((dir.length() > 0) && (P_chdir(dir.c_str()) < 0)) {
            sprintf(errorLine, "Cannot chdir to '%s': %s\n", dir.c_str(), 
                    strerror(errno));
            fprintf(stderr, "Cannot chdir to '%s': %s\n", dir.c_str(), 
                    strerror(errno));
            pdlogLine(errorLine);
            P__exit(-1);
        }
        
        char **argv_array = new char*[argv.size()+1];
        for(unsigned i=0; i<argv.size(); i++)
            argv_array[i] = const_cast<char *>(argv[i].c_str());
        argv_array[argv.size()] = NULL;
        
        char *path = new char[  argv0.length() + 5];
        strcpy(path, argv0.c_str());
        getBPatch().setTypeChecking(false);

        // hand off info about how to start a paradynd to the application.
        //   used to catch rexec calls, and poe events.
        //
        char* paradynInfo = new char[1024];
        sprintf(paradynInfo, "PARADYN_MASTER_INFO= ");
        for (unsigned i=0; i < pd_process::arg_list.size(); i++) {
           const char *str;

           str = P_strdup(pd_process::arg_list[i].c_str());
           if (!strcmp(str, "-l1")) {
              strcat(paradynInfo, "-l0");
           } else {
              strcat(paradynInfo, str);
           }
           strcat(paradynInfo, " ");
        }

        startup_printf("%s[%d]:  setting '%s' in env\n", FILE__, __LINE__, paradynInfo);
        //  since we are not using the envp arg to processCreate, we can just stick
        //  it in our own environment and it will be transferred
        P_putenv(paradynInfo);

        dyninst_process = getBPatch().processCreate(path, 
                                                    (const char **) argv_array, NULL, 
                                                    stdin_fd, stdout_fd, stderr_fd);
        if (!dyninst_process) {
            // createProcess will print proper error message in the paradyn msg box
            P__exit(-1);
        }
        
        delete []argv_array;
        delete []path;
    }
    else {
        dyninst_process = MPI_proc;
        getBPatch().registerExecCallback(paradynExecDispatch);
        getBPatch().registerPostForkCallback(paradynPostForkDispatch);
        getBPatch().registerExitCallback(paradynExitDispatch);
    }
    if (!dyninst_process) {
        // createProcess will print proper error message in the paradyn msg box
        P__exit(-1);
    }
    
    
    created_via_attach = false;
    img = new pd_image(dyninst_process->getImage(), this);
    
    pdstring img_name = img->get_file();
    if (img_name == (char *) NULL) {
        //  this will cause an assertion failure in newResource()
        fprintf(stderr, "%s[%d]:  unnamed image!\n", __FILE__, __LINE__);
    }
    pdstring buff = pdstring(itos(getPid())); // + pdstring("_") + getHostName();
    
    rid = resource::newResource(machineResource, // parent
                                (void*)this, // handle
                                nullString, // abstraction
                                img->get_file(), // process name
                                timeStamp::ts1970(), // creation time
                                buff, // unique name (?)
                                ProcessResourceType,
                                MDL_T_STRING, // mdl type (?)
                                true);
    
    if (!dyninst_process) {
        // Ummm.... 
        return;
    }
    
    initCpuTimeMgr();
    
    // Initialize the shared memory segment
    sharedMemManager = new shmMgr(dyninst_process,
                                  7000, // Arbitrary constant for shared key
                                  SHARED_SEGMENT_SIZE,
                                  false); // Don't leave around -- if we're attached, then the
                                  // inferior process will have the segment as long is it 
                                  // exists
    
    shmMetaData = new sharedMetaData(sharedMemManager, MAX_NUMBER_OF_THREADS);
    
    // Set the paradyn RT lib name
    if (!getParadynRTname()) {
        assert(0 && "Need to do cleanup");
    }
}

// Attach constructor
pd_process::pd_process(const pdstring &progpath, int pid)
        : monitorFunc(NULL),
          os_handle(0),
          numOfActCounters_is(0), numOfActProcTimers_is(0),
          numOfActWallTimers_is(0), 
          cpuTimeMgr(NULL),
#ifdef PAPI
          papi(NULL),
#endif
          paradynRTState(libUnloaded),
          cumulativeObsCost(0),
          lastObsCostLow(0),
          inExec(false),
					canReportResources_(false)
{
    getBPatch().setTypeChecking(false);
    dyninst_process = getBPatch().processAttach(progpath.c_str(), pid);
    img = new pd_image(dyninst_process->getImage(), this);
    pdstring img_name = img->get_file();
    if (img_name == (char *) NULL) {
      //  this will cause an assertion failure in newResource()
      fprintf(stderr, "%s[%d]:  unnamed image!\n", __FILE__, __LINE__);
    }

    pdstring buff = pdstring(itos(getPid())); // + pdstring("_") + getHostName();
    rid = resource::newResource(machineResource, // parent
                                (void*)this, // handle
                                nullString, // abstraction
                                img->get_file(),
                                timeStamp::ts1970(), // creation time
                                buff, // unique name (?)
                                ProcessResourceType,
                                MDL_T_STRING, // mdl type (?)
                                true
                                );

    if (!dyninst_process) {
        // Ummm.... 
        return;
    }

    created_via_attach = true;

    initCpuTimeMgr();

    // Initialize the shared memory segment
    sharedMemManager = new shmMgr(dyninst_process,
                                  7000, // Arbitrary constant for shared key
                                  SHARED_SEGMENT_SIZE,
                                  false // Don't leave around -- if we're attached, then the
                                  // inferior process will have the segment as long is it 
                                  // exists
                                  );
    shmMetaData = new sharedMetaData(sharedMemManager, MAX_NUMBER_OF_THREADS);

    // Set the paradyn RT lib name
    if (!getParadynRTname())
        assert(0 && "Need to do cleanup");

}

extern void CallGraphSetEntryFuncCallback(pdstring exe_name, pdstring r, int tid);

// fork constructor
pd_process::pd_process(const pd_process &parent, BPatch_process *childDynProc) :
        dyninst_process(childDynProc), 
        monitorFunc(NULL),
        os_handle(0),
        cpuTimeMgr(NULL),
#ifdef PAPI
        papi(NULL),
#endif
        paradynRTState(libLoaded),
        cumulativeObsCost(0), //  should costs be copied from parents ??
        lastObsCostLow(0),    //  guessing not.
        inExec(false),
        paradynRTname(parent.paradynRTname),
        canReportResources_(true)
{
   img = new pd_image(dyninst_process->getImage(), this);

   // Call fork initialization code
   BPatch_Vector<BPatch_snippet *>fork_init_args;
   BPatch_Vector<BPatch_function *>fork_init_func;

   if ((NULL == dyninst_process->getImage()->findFunction("PARADYN_init_child_after_fork",
                                                    fork_init_func)) ||
       fork_init_func.size() == 0) {
       assert(0 && "Failed to find post-fork initialization function");
   }
   BPatch_funcCallExpr fork_init_expr(*(fork_init_func[0]), fork_init_args);

   if (dyninst_process->oneTimeCode(fork_init_expr) != (void *)123)
       fprintf(stderr, "Error running forked child init function\n");
   
   pdstring img_name = img->get_file();
   if (img_name == (char *) NULL) {
     //  this will cause an assertion failure in newResource()
     fprintf(stderr, "%s[%d]:  unnamed image!\n", __FILE__, __LINE__);
   }

   pdstring buff = pdstring(itos(getPid())); // + pdstring("_") + getHostName();
   rid = resource::newResource(machineResource, // parent
                               (void*)this, // handle
                               nullString, // abstraction
                               img->get_file(),
                               timeStamp::ts1970(), // creation time
                               buff, // unique name (?)
                               ProcessResourceType,
                               MDL_T_STRING, // mdl type (?)
                               true
                               );

   setLibState(paradynRTState, libReady);

   // Okay, time to rock and roll... that is, make a copy of the parent's
   // shared memory
   sharedMemManager = new shmMgr(parent.sharedMemManager, childDynProc,
                                 true /* Attach at same addr as in parent */);
   // Already initialized
   shmMetaData = new sharedMetaData(parent.shmMetaData, sharedMemManager);
   // Don't need to update observed cost addr -- the application side (that
   // the process class cares about) hasn't changed.

   theVariableMgr = new variableMgr(*parent.theVariableMgr, this,
                                    getSharedMemMgr());
   theVariableMgr->initializeVarsAfterFork();

   created_via_attach = parent.wasCreatedViaAttach();

   // And the time manager...
   initCpuTimeMgr();
   tp->newProgramCallbackFunc(defaultStream, getPid(), arg_list, 
                              machineResource->part_name(),
                              false, wasRunningWhenAttached());
   
   // Thread time. We keep our own list of threads in the process.
   BPatch_Vector<BPatch_thread *> threads;
   childDynProc->getThreads(threads);
   for (unsigned i=0; i<threads.size(); i++)
   {
      pd_thread *pd_thr = new pd_thread(threads[i], this);
      addThread(pd_thr);
   }
}

pd_process::~pd_process() {
   cpuTimeMgr->destroyMechTimers(this);

   delete dyninst_process;
   dyninst_process = NULL;

   delete sharedMemManager;
   sharedMemManager = NULL;

   delete theVariableMgr;
   theVariableMgr = NULL;
   closeOSHandle();
}

void pd_process::processCost(unsigned obsCostLow,
                          timeStamp wallTime,
                          timeStamp processTime) 
{

  // wallTime and processTime should compare to DYNINSTgetWallTime() and
  // DYNINSTgetCPUtime().

  // check for overflow, add to running total, convert cycles to seconds, and
  // report.  Member vrbles of class process: lastObsCostLow and cumulativeObsCost
  // (the latter a 64-bit value).

  // code to handle overflow used to be in rtinst; we borrow it pretty much
  // verbatim. (see rtinst/RTposix.c)
  if (obsCostLow < lastObsCostLow) {
    // we have a wraparound
    cumulativeObsCost += ((unsigned)0xffffffff - lastObsCostLow) + obsCostLow + 1;
  }
  else
    cumulativeObsCost += (obsCostLow - lastObsCostLow);

  lastObsCostLow = obsCostLow;
  //  sampleVal_cerr << "processCost- cumulativeObsCost: " << cumulativeObsCost << "\n;
  timeLength observedCost((int64_t) cumulativeObsCost, getCyclesPerSecond());
  // timeUnit tu = getCyclesPerSecond(); // just used to print out
  //  sampleVal_cerr << "processCost: cyclesPerSecond=" << tu
  //             << "; cum obs cost=" << observedCost << "\n";

  // Notice how most of the rest of this is copied from processCost() of
  // metric.C.  Be sure to keep the two "in sync"!

  extern costMetric *totalPredictedCost; // init.C
  extern costMetric *observed_cost;      // init.C

  const timeStamp lastProcessTime =
    totalPredictedCost->getLastSampleProcessTime(dyninst_process);
  //  sampleVal_cerr << "processCost- lastProcessTime: " <<lastProcessTime << "\n";
  // find the portion of uninstrumented time for this interval
  timeLength userPredCost = timeLength::sec() + getCurrentPredictedCost();
  //  sampleVal_cerr << "processCost- userPredCost: " << userPredCost << "\n";
  const double unInstTime = (processTime - lastProcessTime) / userPredCost;
  //  sampleVal_cerr << "processCost- unInstTime: " << unInstTime << "\n";
  // update predicted cost
  // note: currentPredictedCost is the same for all processes
  //       this should be changed to be computed on a per process basis
  pdSample newPredCost = totalPredictedCost->getCumulativeValue(dyninst_process);
  //  sampleVal_cerr << "processCost- newPredCost: " << newPredCost << "\n";
  timeLength tempPredCost = getCurrentPredictedCost() * unInstTime;
  //  sampleVal_cerr << "processCost- tempPredCost: " << tempPredCost << "\n";
  newPredCost += pdSample(tempPredCost.getI(timeUnit::ns()));
  //  sampleVal_cerr << "processCost- tempPredCost: " << newPredCost << "\n";
  totalPredictedCost->updateValue(dyninst_process, wallTime, newPredCost, processTime);
  // update observed cost
  pdSample sObsCost(observedCost);
  observed_cost->updateValue(dyninst_process, wallTime, sObsCost, processTime);
}

 

bool pd_process::doMajorShmSample() 
{

   if( !isPARADYNBootstrappedYet()) {
      return false;
   }

   bool result = true; // will be set to false if any processAll() doesn't complete
                       // successfully.

   if(! getVariableMgr().doMajorSample())
      result = false;

   if(isTerminated()) {
      return false;
   }

   // need to check this again, process could have execed doMajorSample
   // and it may be midway through setting up for the exec

   if( !isPARADYNBootstrappedYet()) {
      return false;
   }

   // inferiorProcessTimers used to take in a non-dummy process time as the
   // 2d arg, but it looks like that we need to re-read the process time for
   // each proc timer, at the time of sampling the timer's value, to avoid
   // ugly jagged spikes in histogram (i.e. to avoid incorrect sampled 
   // values).  Come to think of it: the same may have to be done for the 
   // wall time too!!!

   const timeStamp theProcTime = getCpuTime();
   const timeStamp curWallTime = getWallTime();

   // need to check this again, process could have execed doMajorSample
   // and it may be midway through setting up for the exec
   if( !isPARADYNBootstrappedYet()) {
      return false;
   }

   // Now sample the observed cost.
   const unsigned theCost = *(shmMetaData->getObservedCost());

   processCost(theCost, curWallTime, theProcTime);

   return result;
}

bool pd_process::doMinorShmSample() {
   // Returns true if the minor sample has successfully completed all
   // outstanding samplings.
   bool result = true; // so far...

   if(! getVariableMgr().doMinorSample())
      result = false;

   return result;
}

extern pdRPC *tp;
extern void disableAllInternalMetrics();

void pd_process::handleExit(int exitStatus) {
   // The below vector is a kludge put in as a "safer" method of handling
   // this issue just before the release.  After the release, this method
   // shouldn't be used.  We're using this to delete the pd_process when
   // Paradyn exits.  The better appoach would be to delete the pd_process
   // when the process actually exits, as we find out in
   // paradyn_handleProcessExit.  We don't have opportunity so close to the
   // release to flush out any bugs related to this, so that's why we're
   // deleting all pd_processes when Paradyn exits.
   getProcMgr().exitedProcess(this);

   // don't do a final sample for terminated processes
   // this is because there could still be active process timers
   // we can't get a current process time since the process no longer
   // exists, so can't sample these active process timers   
   if(exitStatus == 0) {
      doMajorShmSample();
   }

   reportInternalMetrics(true);

   metricFocusNode::handleExitedProcess(this);

   if(multithread_capable()) {
      // retire any thread resources which haven't been retired yet
      threadMgr::thrIter itr = beginThr();
      while(itr != endThrMark()) {
         pd_thread *thr = *itr;
         itr++;
         assert(thr->get_rid() != NULL);
         tp->retiredResource(defaultStream, thr->get_rid()->full_name());
      }
   }

   assert(get_rid() != NULL);
   tp->retiredResource(defaultStream, get_rid()->full_name());
   tp->processStatus(defaultStream, getPid(), procExited);

   if (BPatch::getBPatch()->getProcesses()->size() == 0)
      disableAllInternalMetrics();

}

void pd_process::initAfterFork(pd_process * /*parentProc*/) {
   initCpuTimeMgr();

   tp->newProgramCallbackFunc(defaultStream, getPid(), arg_list, 
                              machineResource->part_name(),
                              false, wasRunningWhenAttached());
}

/********************************************************************
 **** Fork/Exec handling code                                    ****
 ********************************************************************/

void pd_process::paradynPreForkDispatch(BPatch_thread* p,
                                        BPatch_thread* /*child*/) 
{
   BPatch_process *parent = p->getProcess();
   pd_process *matching_pd_process = getProcMgr().find_pd_process(parent);
   if(matching_pd_process)
      matching_pd_process->preForkHandler();
}

void pd_process::paradynPostForkDispatch(BPatch_thread *parent_thread, BPatch_thread *child_thread) 
{
   if( pdFlavor == "mpi" ) {
     child_thread->detach( true );
   	 }
   else {
     BPatch_process *parent = parent_thread->getProcess();
     BPatch_process *child = child_thread->getProcess();
     pd_process *matching_pd_process = getProcMgr().find_pd_process(parent);
     if(matching_pd_process)
        matching_pd_process->postForkHandler(child);
     }
}

void pd_process::paradynExecDispatch(BPatch_thread *dyn_thread) 
{
   BPatch_process *dyn_proc = dyn_thread->getProcess();
   pd_process *matching_pd_process = getProcMgr().find_pd_process(dyn_proc);
   if(matching_pd_process) {
      matching_pd_process->execHandler();
   }
}

void pd_process::paradynExitDispatch(BPatch_thread *thread, 
                                     BPatch_exitType exit_type) {
   BPatch_process *dyn_proc = thread->getProcess();
   pd_process *matching_pd_process = getProcMgr().find_pd_process(dyn_proc);
   int code = 0;
   assert(thread->terminationStatus() == exit_type);

   if(exit_type == ExitedNormally) {      
      code = thread->getExitCode();
   } else if(exit_type == ExitedViaSignal) {
      code = - (thread->getExitSignal());
   } else   assert(false);

   if(matching_pd_process)
      matching_pd_process->handleExit(code);
}

void pd_process::preForkHandler() {
  // Nothing to do here...
}

// this is the parent
void pd_process::postForkHandler(BPatch_process *child) {
   BPatch_process *parent = dyninst_process;
   assert(child->isStopped());

   pd_process *parentProc = getProcMgr().find_pd_process(parent->getPid());
   if (!parentProc) {
     pdlogLine("Error in forkProcess: could not find parent process\n");
     return;
   }

   pd_process *childProc = new pd_process(*parentProc, child);
   getProcMgr().addProcess(childProc);
   metricFocusNode::handleFork(parentProc, childProc);
   childProc->findThreads();

   // I don't think we want to continue the process here... hand it back
   // to Dyninst -- bernat, 28APR04
   childProc->continueProc();
   // parent process will get continued by unix.C/handleSyscallExit
}

void pd_process::execHandler() {
    // We need to reload the Paradyn library
    paradynRTState = libUnloaded; // It was removed when we execed
    inExec = true;

    // create a new pd_image because there is a new dyninst image
    delete img;
    img = new pd_image(dyninst_process->getImage(), this);

    // The shared segment is gone... so delete and remake
    delete shmMetaData;
    delete sharedMemManager;

    // Sigh... the library's gone as well

    sharedMemManager = new shmMgr(dyninst_process,
                                  7000, // Arbitrary constant for shared key
                                  SHARED_SEGMENT_SIZE,
                                  false // Don't leave around -- if we're attached, then the
                                  // inferior process will have the segment as long is it 
                                  // exists
                                  );
    shmMetaData = new sharedMetaData(sharedMemManager, MAX_NUMBER_OF_THREADS);

    // Initialize shared memory before we re-load the paradyn lib
    if (!sharedMemManager->initialize()) {
      fprintf(stderr, "%s[%d]:  failed to init shared mem mgr, fatal...\n", __FILE__, __LINE__);
      return;
    }

    loadParadynLib(exec_load);
}
/********************************************************************
 **** Paradyn runtime library code                               ****    
 ********************************************************************/

// Load and initialize the paradyn runtime library.
bool pd_process::loadParadynLib(load_cause_t ldcause) 
{
   bool result;
   initOSPreLib();

   assert(isStopped());
   
   pdstring buffer = pdstring("PID=") + pdstring(itos(getPid()));
   buffer += pdstring(", loading Paradyn RT lib via iRPC");
   pdstatusLine(buffer.c_str());
   
   setLibState(paradynRTState, libLoading);
   
   pdstring libname = formatLibParadynName(paradynRTname);

   result = dyninst_process->loadLibrary(libname.c_str());
   if (!result)
   {
      fprintf(stderr, "%s[%d]:  failed to load %s, fatal...\n",
              __FILE__, __LINE__, libname.c_str());
      return false;
   }

   if (!runParadynInit(ldcause)) {
      fprintf(stderr, "%s[%d]:  failed set lib params for %s, fatal...\n",
              __FILE__, __LINE__, paradynRTname.c_str());
      return false;
   }

   setLibState(paradynRTState, libLoaded);
   
   buffer = pdstring("PID=") + pdstring(itos(getPid()));
   buffer += pdstring(", finalizing Paradyn RT lib");
   pdstatusLine(buffer.c_str());
   
   // Now call finalizeParadynLib which will handle any initialization
   finalizeParadynLib(ldcause);

   assert(reachedLibState(paradynRTState, libReady));
   return true;
}

/**
 * Causes PARADYN_init in the RT library to be run.
 **/
bool pd_process::runParadynInit(load_cause_t ldcause)
{
   BPatch_Vector<BPatch_snippet *> args;    

   //Argument 1 is the paradynPID
   int paradynPid = dyninst_process->getPid();
   BPatch_constExpr pid_param(paradynPid);
   args.push_back(&pid_param);

   //Argument 2 tells how the process was created
   int creationMethod;
   if(ldcause == create_load)      creationMethod = 0;
   else if(ldcause == attach_load) creationMethod = 1;
   else if(ldcause == exec_load)   creationMethod = 4;
   else assert(0);
   BPatch_constExpr create_param(creationMethod);
   args.push_back(&create_param);

   //Argument 3 is a pointer to the virtual timers
   if (!shmMetaData->initialize()) {
      assert(0 && "Failed to allocate required shared metadata variables");
   }    
   Address daemonVirtTimers = (Address) shmMetaData->getVirtualTimers();
   Address virtTimers = getSharedMemMgr()->daemonToApplic(daemonVirtTimers);
   BPatch_constExpr timers_param((void *) virtTimers);
   args.push_back(&timers_param);

   //Argument 4 is the Observed cost
   Address daemonCost = (Address) shmMetaData->getObservedCost();
   Address appObsCost = getSharedMemMgr()->daemonToApplic(daemonCost);
   dyninst_process->PDSEP_updateObservedCostAddr(appObsCost);
   BPatch_constExpr cost_param(appObsCost);
   args.push_back(&cost_param);

   //Find the function 'PARADYN_init'
   BPatch_image *appImage = dyninst_process->getImage();
   assert(appImage);     
   BPatch_Vector<BPatch_function *> funcs;
   appImage->findFunction("PARADYNinit", funcs);
   if (funcs.size() != 1)
   {
      fprintf(stderr, "[%s:%u] - Paradyn internal error. "
              "Found %u copies of PARADYN_init.  Expected 1.\n",
              __FILE__, __LINE__, funcs.size());
      return false;
   }
   BPatch_function *PARADYN_init = funcs[0];
    
   //Call it via an inferior RPC
   BPatch_funcCallExpr init_paradyn_rt(*PARADYN_init, args);
   dyninst_process->oneTimeCode(init_paradyn_rt);
   
   return true;
}

bool pd_process::finalizeParadynLib(load_cause_t ldcause)
{
   pdstring str;

   if (reachedLibState(paradynRTState, libReady))
      return true;
   
   if (ldcause != attach_load) {
      // Install initial instrumentation requests
      installInstrRequests(initialRequestsPARADYN); 
      str=pdstring("PID=") + pdstring(itos(dyninst_process->getPid())) + 
         ", propagating mi's...";
      pdstatusLine(str.c_str());
   }

   if (ldcause == exec_load) {
      pd_execCallback(this);
   }

   str=pdstring("PID=") + pdstring(itos(dyninst_process->getPid())) + 
      ", executing new-prog callback...";
   pdstatusLine(str.c_str());
    
   timeStamp currWallTime = (ldcause==exec_load) ? timeStamp::ts1970() 
                                                 : getWallTime();
   if (!isInitFirstRecordTime())
      setFirstRecordTime(currWallTime);
   assert(isStopped());
   
   //   tp->newProgramCallbackFunc(dyninst_process->getPid(), arg_list, 
   //                           machineResource->part_name(),
   //                           (ldcause==exec_load),
   //                           wasRunningWhenAttached());
   // in paradyn, this will call paradynDaemon::addRunningProgram().
   // If the state of the application as a whole is 'running' paradyn will
   // soon issue an igen call to us that'll continue this process.
   if (ldcause != exec_load)
      tp->setDaemonStartTime(defaultStream,getPid(), 
                             currWallTime.getD(timeUnit::sec(), 
                             timeBase::bStd()));
   
   // verify that the wall and cpu timer levels chosen by the daemon
   // are available in the rt library
   verifyTimerLevels();
   writeTimerLevels();
   
   // Set library state to "ready"
   setLibState(paradynRTState, libReady);
   return true;
}

bool pd_process::getParadynRTname() 
{
    // Replace with better test for MT-ness
   char ParadynEnvVar[20];
   strcpy(ParadynEnvVar, "PARADYN_LIB");
    
    // If there is a default set, use it
    if (defaultParadynRTname.length())
        paradynRTname = defaultParadynRTname;
    else {
        // check the environment variable
        if (getenv(ParadynEnvVar) != NULL) {
            paradynRTname = getenv(ParadynEnvVar);
        } else {
            pdstring msg = pdstring("Environment variable " + pdstring(ParadynEnvVar)
                                + " has not been defined for process "
                                + pdstring(itos(getPid())));
            showErrorCallback(101, msg);
            cerr << "Environment variable " << ParadynEnvVar << " not set!" << endl;
            return false;
        }
    }

#if !defined(i386_unknown_nt4_0)
    // TODO: make equivalent for NT
    // Check to see if the library given exists.
    if (access(paradynRTname.c_str(), R_OK)) {
        pdstring msg = pdstring("Runtime library ") + paradynRTname
        + pdstring(" does not exist or cannot be accessed!");
        showErrorCallback(101, msg);
        cerr << "Paradyn lib is not accessible!" << endl;
        return false;
    }
#endif
    return true;
}


bool pd_process::loadAuxiliaryLibrary(pdstring libname) {
    auxLibState = libUnloaded;

    setLibState(auxLibState, libLoading);
    if (!dyninst_process->loadLibrary(libname.c_str())) {
      fprintf(stderr, "%s[%d]:  failed to load library %s\n", __FILE__, __LINE__, libname.c_str());
      assert(0);
    }

    setLibState(auxLibState, libLoaded);
    return true;
}

void pd_process::loadAuxiliaryLibraryCallback(process* /*ignored*/,
                                              unsigned /* rpc_id */,
                                              void *data, void* /*ignored*/) {
    pd_process *p = (pd_process *)data;
    setLibState(p->auxLibState, libLoaded);
}

bool bForceSoftwareLevelCpuTimer() {
   char *pdkill;
   pdkill = getenv("PD_SOFTWARE_LEVEL_CPU_TIMER");
   if( pdkill )
      return true;
   else
      return false;
}

void pd_process::initCpuTimeMgr() {
   if(cpuTimeMgr != NULL)  delete cpuTimeMgr;
   cpuTimeMgr = new cpuTimeMgr_t();
   initCpuTimeMgrPlt();
   
   if(bForceSoftwareLevelCpuTimer()) {
      cpuTimeMgr_t::mech_t *tm =
         cpuTimeMgr->getMechLevel(cpuTimeMgr_t::LEVEL_TWO);
      cpuTimeMgr->installMechLevel(cpuTimeMgr_t::LEVEL_BEST, tm);    
      if(bShowTimerInfo())
         cerr << "Forcing to software level cpu timer\n";
   } else {
      cpuTimeMgr->determineBestLevels(this);
   }
   cpuTimeMgr_t::timeMechLevel ml = cpuTimeMgr->getBestLevel();
   //cerr << "Chosen cpu timer level: " << int(ml)+1 << "  "
   //     << *cpuTimeMgr->getMechLevel(ml)
   //     << "(timeBase is irrelevant for cpu time)\n\n";
   if(bShowTimerInfo()) {
      cerr << "Chosen cpu timer level: " << int(ml)+1 << "  "
           << *cpuTimeMgr->getMechLevel(ml)
           << "(timeBase is irrelevant for cpu time)\n\n";    
   }
}

timeStamp pd_process::getCpuTime(int lwp_id) {
   if(isTerminated()) {
      return timeStamp::tsLongAgoTime();
   }
   
   return cpuTimeMgr->getTime(this, lwp_id, cpuTimeMgr_t::LEVEL_BEST);
   /* can nicely handle case when we allow exceptions
      } catch(LevelNotInstalled &) {
      cerr << "getCpuTime: timer level not installed\n";
      assert(0);
      }
   */
}

bool pd_process::yesAvail() {
   return true; 
}

rawTime64 pd_process::getRawCpuTime_hw(int lwp)
{
   if(lwp == time_for_whole_program) {
      // get cpu time for whole process
      return getAllLwpRawCpuTime_hw();
   } else {
      threadMgr::thrIter itr = beginThr();
      pd_thread *thr = NULL;
      for (; itr != endThrMark(); itr++)
         if ((*itr)->get_lwp() == lwp)
         {
            thr = *itr;
            break;
         }
      assert(thr);
      return thr->getRawCpuTime_hw();
   }
}

rawTime64 pd_process::getRawCpuTime_sw(int lwp)
{
   if(lwp == time_for_whole_program) {
      // get cpu time for whole process
      return getAllLwpRawCpuTime_sw();      
   } else {
      threadMgr::thrIter itr = beginThr();
      pd_thread *thr = NULL;
      for (; itr != endThrMark(); itr++) {
         if ((*itr)->get_lwp() == lwp)
         {
            thr = *itr;
            break;
         }
      }
      assert(thr);
      return thr->getRawCpuTime_sw();
   }
}

rawTime64 pd_process::getRawCpuTime(int lwp) {
   return cpuTimeMgr->getRawTime(this, lwp, cpuTimeMgr_t::LEVEL_BEST);
   /* can nicely handle case when we allow exceptions
      } catch(LevelNotInstalled &) {
      cerr << "getRawCpuTime: timer level not installed\n";
      assert(0);
      }
   */
}

timeStamp pd_process::units2timeStamp(int64_t rawunits) {
   return cpuTimeMgr->units2timeStamp(rawunits, cpuTimeMgr_t::LEVEL_BEST);
   /* can nicely handle case when we allow exceptions
      } catch(LevelNotInstalled &) {
      cerr << "units2timeStamp: timer level not installed\n";
      assert(0);
      }
   */
}

timeLength pd_process::units2timeLength(int64_t rawunits) {
   return cpuTimeMgr->units2timeLength(rawunits, cpuTimeMgr_t::LEVEL_BEST);

   /* can nicely handle case when we allow exceptions
      } catch(LevelNotInstalled &) {
      cerr << "units2timeStamp: timer level not installed\n";
      assert(0);
      }
   */
}

void pd_process::verifyTimerLevels() {
   long hintBestCpuTimerLevel, hintBestWallTimerLevel;
   int appAddrWidth = getImage()->getAddressWidth();

   BPatch_image *appImage = dyninst_process->getImage();
   assert(appImage);

   const char *vname = "hintBestCpuTimerLevel";
   BPatch_variableExpr *v_hint = appImage->findVariable(vname);
   if (! v_hint) {
     fprintf(stderr, "%s[%d]:  could not find var named %s\n", 
             __FILE__, __LINE__, vname);
     assert(0  && "fatal init error");
   }
   if (! v_hint->readValue((void *) &hintBestCpuTimerLevel, appAddrWidth)) {
      fprintf(stderr, "%s[%d]:  could not read var named %s\n", 
              __FILE__, __LINE__, vname);
      //return;
   }

   int curCpuTimerLevel = int(cpuTimeMgr->getBestLevel())+1;
   if(curCpuTimerLevel < hintBestCpuTimerLevel) {
      char errLine[150];
      sprintf(errLine, "Chosen cpu timer level (%d) is not available in the rt"
              " library (%ld is best).\n", curCpuTimerLevel,
              hintBestCpuTimerLevel);
      fprintf(stderr, errLine);
      assert(0);
   }

   vname = "hintBestWallTimerLevel";
   v_hint = appImage->findVariable(vname);
   if (! v_hint) {
     fprintf(stderr, "%s[%d]:  could not find var named %s\n", __FILE__, __LINE__, vname);
     assert(0  && "fatal init error");
   }
   if (! v_hint->readValue((void *) &hintBestWallTimerLevel, appAddrWidth)) {
      fprintf(stderr, "%s[%d]:  could not read var named %s\n", __FILE__, 
              __LINE__, vname);
      //return;
   }

   int curWallTimerLevel = int(getWallTimeMgr().getBestLevel())+1;
   if(curWallTimerLevel < hintBestWallTimerLevel) {
      char errLine[150];
      sprintf(errLine, "Chosen wall timer level (%d) is not available in the"
              " rt library (%ld is best).\n", curWallTimerLevel,
              hintBestWallTimerLevel);
      fprintf(stderr, errLine);
      assert(0);
   }
}

// being disabled since written for IRIX platform, now that don't support
// this platform, don't have way to test changes needed in this feature
// feel free to bring back to life if the need arises again
/*
bool pd_process::writeTimerFuncAddr_Force32(const char *rtinstVar,
                                            const char *rtinstFunc)
{
   bool err = false;
   int rtfuncAddr = findInternalAddress(rtinstFunc, true, err);
   assert(err==false);

   err = false;
   int timeFuncVarAddr = findInternalAddress(rtinstVar, true, err);
   assert(err==false);

   return writeTextSpace((void *)(timeFuncVarAddr),
			 sizeof(rtfuncAddr), (void *)(&rtfuncAddr));
}
*/

/* That is, get the address of the thing to set the function pointer to.  In
   most cases, this will be the address of the desired function, however, on
   AIX it is the address of a structure which in turn points to the desired
   function. 
*/
Address pd_process::getTimerQueryFuncTransferAddress(const char *helperFPtr) {
   Address transferAddr = 0;
   int appAddrWidth = getImage()->getAddressWidth();

   BPatch_image *appImage = dyninst_process->getImage();
   assert(appImage);

   const char *vname = helperFPtr;
   BPatch_variableExpr *v_hint = appImage->findVariable(vname);
   if (! v_hint) {
     fprintf(stderr, "%s[%d]:  could not find var named %s\n",
             __FILE__, __LINE__, vname);
     assert(0  && "fatal internal error");
   }
   if (! v_hint->readValue((void *) &transferAddr, appAddrWidth)) {
      fprintf(stderr, "%s[%d]:  could not read var named %s\n",
              __FILE__, __LINE__, vname);
      //return;
   }

   return transferAddr;
}

bool pd_process::writeTimerFuncAddr_(const char *rtinstVar,
				   const char *rtinstHelperFPtr)
{
   Address rtfuncAddr = getTimerQueryFuncTransferAddress(rtinstHelperFPtr);
   BPatch_image *appImage = dyninst_process->getImage();
   assert(appImage);

   const char *vname = rtinstVar;
   BPatch_variableExpr *v_funcaddr = appImage->findVariable(vname);
   if (! v_funcaddr) {
     fprintf(stderr, "%s[%d]:  could not find var named %s\n",
             __FILE__, __LINE__, vname);
     assert(0  && "fatal internal error");
   }
   if (! v_funcaddr->writeValue((void *) &rtfuncAddr, sizeof(rtfuncAddr),
                                 false /*saveWorld*/)) {
      fprintf(stderr, "%s[%d]:  could not write var named %s\n",
              __FILE__, __LINE__, vname);
      return false;
   }

   return true;
}

void pd_process::writeTimerFuncAddr(const char *rtinstVar, 
				 const char *rtinstHelperFPtr)
{   
   bool result;
   // being disabled since written for IRIX platform, now that don't support
   // this platform, don't have way to test changes needed in this feature
   // feel free to bring back to life if the need arises again
   //int appAddrWidth = getImage()->getObject().getAddressWidth();
   //if(sizeof(Address)==8 && appAddrWidth==4)
   //result = writeTimerFuncAddr_Force32(rtinstVar, rtinstFunc);     
   //else
   result = writeTimerFuncAddr_(rtinstVar, rtinstHelperFPtr);          

   if(result == false) {
     cerr << "!!!  Couldn't write timer func address into rt library !!\n";
   }
}

void pd_process::writeTimerLevels() {
   char rtTimerStr[61];
   rtTimerStr[60] = 0;
   pdstring cStr = cpuTimeMgr->get_rtTimeQueryFuncName(cpuTimeMgr_t::LEVEL_BEST);
   strncpy(rtTimerStr, cStr.c_str(), 59);
   writeTimerFuncAddr("PARADYNgetCPUtime", rtTimerStr);
   //logStream << "Setting cpu time retrieval function in rtinst to " 
   //     << rtTimerStr << "\n" << flush;
   
   pdstring wStr=wallTimeMgr->get_rtTimeQueryFuncName(wallTimeMgr_t::LEVEL_BEST);
   strncpy(rtTimerStr, wStr.c_str(), 59);
   writeTimerFuncAddr("PARADYNgetWalltime", rtTimerStr);
   //logStream << "Setting wall time retrieval function in rtinst to " 
   //     << rtTimerStr << "\n" << flush;
}


//
// Fill in the statically determinable components of the call
//  graph for process.  "statically determinable" refers to
//  the problem that some call destinations cannot be determined
//  statically, but rather instrumentation must be inserted to
//  determine the actual target (which may change depending on when 
//  the call is executed).  For example conmsider the assembly code 
//  fragment:
//   ....
//   call <random>  // puts random number (in some range) in g1
//   nop
//   call %g1
//   nop
//   ....
//  Code where the call target cannot be statically determined has
//   been observed w/ pointers to functions, switch statements, and 
//   some heavily optimized SPARC code.
//  Parameters:
//   Called just after an image is parsed and added to process
//   (image can represent either a.out or shared object).  
//   img - pointer to image just parsed and added.
//   shared_object - boolean inidcating whether img refers to an
//   a.out or shared object.
//
//  NOTE : Paradynd keeps 1 copy of each image, even when that image
//   appears in multiple processes (e.g. when that image represents
//   a shared object).  However, for keeping track of call graphs,
//   we want to keep a SEPERATE call graph for every process - this
//   includes the images which may be shared by multiple processes.
//   The reason for this is that when adding dynamically determined
//   call destinations, we want them to apply ONLY to the process
//   in which they are observed, NOT to other processes which may share
//   e.g. the same shared library. 

extern void CallGraphAddProgramCallback(pdstring name);
extern void CallGraphFillDone(pdstring exe_name);
extern void AddCallGraphStaticChildrenCallback(pdstring exe_name, pdstring r,
					       const pdvector<pdstring> children);

void pd_process::FillInCallGraphStatic(bool init_graph, unsigned *checksum )
{
	//	volatile int zoo = 0;
	//while(zoo == 0){;}
   // specify entry point (location in code hierarchy to begin call 
   //  graph searches) for call graph.  Currently, begin searches at
   //  "main" - note that main is usually NOT the actual entry point
   //  there is usually a function which does env specific initialization
   //  and sets up exit handling (at least w/ gcc on solaris).  However,
   //  this function is typically in an excluded module.  Anyway, setting
   //  main as the entry point should usually work fairly well, except
   //  that call graph PC searches will NOT catch time spent in the
   //  environment specific setup of _start.


   BPatch_Vector<BPatch_function *> entry_bpfs;
   BPatch_function *entry_bpf;

   if ((!img->get_dyn_image()->findFunction("main", entry_bpfs)) || !entry_bpfs.size()) 
		abort();

   if (entry_bpfs.size() > 1) 
   {
      //  maybe we should warn here?
   }

   entry_bpf = entry_bpfs[0];

   if(!init_graph)
   {
      CallGraphAddProgramCallback(img->get_file());
   }
   int thr = 0;
   // MT: forward the ID of the first thread.
   if(thr_mgr.size()) 
   {
      threadMgr::thrIter begThrIter = beginThr();
      pd_thread *begThr = *(begThrIter);
      thr = begThr->get_tid();
   }
   if(multithread_capable()) {
		// Temporary hack -- ordering problem
		thr = 1;
   }  
   resource *entry_res = pd_module::getFunctionResource(entry_bpf);
   if (entry_res)
   {
      if(!init_graph)
      {
         CallGraphSetEntryFuncCallback(img->get_file(), entry_res->full_name(), thr);
      }
      else
      {
         *checksum += pd_process::calculate_Checksum(img->get_file());
         *checksum += pd_process::calculate_Checksum(entry_res->full_name());
         *checksum += pd_process::calculate_Checksum(pdstring(itos(thr)));
      }

   }
   // build call graph for executable
   img->FillInCallGraphStatic(this,init_graph,checksum);
   // build call graph for module containing entry point
   // ("main" is not always defined in the executable)
  
   pd_image *pd_main_img = pd_image::get_pd_image(entry_bpf->getModule());

   if (pd_main_img != img)
   {
      pd_main_img->FillInCallGraphStatic(this,init_graph,checksum);
   }
   // TODO: build call graph for all shared objects?
  
   if(!init_graph)
   {  
      CallGraphFillDone(img->get_file());
   }
}

void pd_process::MonitorDynamicCallSites(pdstring function_name) {
	if (!monitorFunc) {
		BPatch_Vector<BPatch_function *> monFuncs;
		if ((!img->get_dyn_image()->findFunction("DYNINSTRegisterCallee",monFuncs))
        || !monFuncs.size()) {
			fprintf(stderr, "%s[%d]:  cannot find function DYNINSTRegisterCallee\n",
              __FILE__, __LINE__);
			return;
		}
		if (monFuncs.size() > 1) {
			//  maybe we should warn here?
		}
      monitorFunc = monFuncs[0];
	}
	assert(monitorFunc);
	resource *r, *p;
	BPatch_module *mod;
	r = resource::findResource(function_name);
	assert(r);
	p = r->parent();
	assert(p);
	
	mod = findModule(p->name(), true);
	if(!mod) {
		//Must be the weird case where main() isn't in the executable

      BPatch_Vector<BPatch_function *> entry_bpfs;
      BPatch_function *entry_bpf;
      if ((!img->get_dyn_image()->findFunction("main", entry_bpfs))
        || !entry_bpfs.size()) abort();
      if (entry_bpfs.size() > 1) {
        //  maybe we should warn here?
      }
      entry_bpf = entry_bpfs[0];
      mod = entry_bpf->getModule();
   }
   assert(mod);
  
   BPatch_function *func;
   BPatch_Vector<BPatch_function *> fbv;
   if (NULL == mod->findFunction(r->name().c_str(), fbv) || !fbv.size()) {
      fprintf(stderr, "%s[%d]: Cannot find %s, currently fatal\n", __FILE__,
              __LINE__, r->name().c_str());
      abort();
   }
   if (fbv.size() > 1) {
      fprintf(stderr, "%s[%d]: Warning, found %d %s()\n", __FILE__, __LINE__,
              fbv.size(), r->name().c_str());
   }
   func = fbv[0];

   //Should I just be using a resource::handle here instead of going through
   //all of this crap to find a pointer to the function???

   BPatch_Vector<BPatch_point*> *callPoints;
   callPoints = func->findPoint(BPatch_subroutine);

   bool needToCont = false;  
   if(!(isStopped() || isTerminated()) && callPoints->size() > 0) {
      // going to insert instrumentation, pause it from up here.
      // pausing at lower levels can cause performance problems, particularly
      // on ptrace systems, where pauses are slow
      if(pauseProc() == true)
         needToCont = true;
   }
  
   for(unsigned i = 0; i < callPoints->size(); i++) {

      BPatch_function *called_func;
      if (NULL == (called_func = (*callPoints)[i]->getCalledFunction())){

        if ((*callPoints)[i]->isDynamic())
          if (!(*callPoints)[i]->monitorCalls(monitorFunc)) {
            fprintf(stderr,
              "%s[%d]:ERROR in daemon, unable to monitorCallSite for function :%s\n",
                    __FILE__, __LINE__,function_name.c_str());
          }

      }
   }

   if(needToCont)
      continueProc();
}

void setLibState(libraryState_t &lib, libraryState_t state) 
{
    if (lib > state) cerr << "Error: attempting to revert library state" << endl;
    else lib = state;
}

bool reachedLibState(libraryState_t lib, libraryState_t state) 
{
   return (lib >= state);
}

virtualTimer *pd_process::getVirtualTimer(unsigned index) {
    virtualTimer *virt_base = (virtualTimer *)shmMetaData->getVirtualTimers();
    return &(virt_base[index]);
}

      // First, define a numeric mapping on top of instrumentation
      // points:

      // 0: Before base tramp
      // 1: In the jump to base tramp
      // 2: base tramp between entry and the call to preInsn
      //    minitramps 
      // 3: preInsn minitramps 
      // 4: base tramp between preInsn minitramps and postInsn
      //    minitramps
      // 5: postInsn minitramps 
      // 6: base tramp between postInsn minitramps and the end of
      //    the base tramp
      // 7: after base tramp

      // This simplification works because we only allow adding
      // minitramps to the beginning or end of the current tramp
      // chain (between 1 and 2 or 2 and 3... but not within 2)

#if 0
typedef enum {beforeInstru, baseEntry, preInsn, 
	      emulInsns, postInsn, baseExit, afterInstru, nowhere} logicalPCLocation_t;

bool pd_process::triggeredInStackFrame(Frame &frame,
                                       BPatch_point *bpPoint,
                                       BPatch_callWhen when,
                                       BPatch_snippetOrder order) {
    fprintf(stderr, "WARNING: skipping catchup!\n");
    return false;

#if 0
  
    // Use a previous lookup if it's there.
    codeRange *range = frame.getRange();
    
    // We still use int_function and instPoint. TODO: replace frame
    // with the BPatch frame, int_function with BPatch_function, etc.

    instPoint *point = bpPoint->PdSEP_instPoint();
    
    // Most of the checking is based on "Am I before, after, or during the
    // instrumentation point". We check that first to see if we need to care.
    Address collapsedFrameAddr;

    // Test 1: if the function associated with the frame
    // is not the instPoint function, return false immediately.
    int_function *func_ptr = range->is_function();
    miniTrampHandle *minitramp_ptr = range->is_minitramp();
    trampTemplate *basetramp_ptr = range->is_basetramp();
    relocatedFuncInfo *reloc_ptr = range->is_relocated_func();
    edgeTrampTemplate *edge_ptr = range->is_edge_tramp();
    multitrampTemplate *multitramp_ptr = range->is_multitramp();

    int_function *frame_func;

    if(func_ptr) {
        collapsedFrameAddr = frame.getPC();
	frame_func = func_ptr;
        if(pd_debug_catchup)
           fprintf(stderr, "     PC in function %s...",
                   func_ptr->prettyName().c_str());
    }
    else if(minitramp_ptr) {
        // Again, quick check for function matching
        trampTemplate *baseT = minitramp_ptr->baseTramp;
        const instPoint *instP = baseT->location;
	
        collapsedFrameAddr = instP->absPointAddr(dyninst_process->lowlevel_process());
	frame_func = instP->pointFunc();

        if(pd_debug_catchup)
           fprintf(stderr, "     PC in minitramp at 0x%lx (%s)...",
                   collapsedFrameAddr,
                   instP->pointFunc()->prettyName().c_str());
    }
    else if(basetramp_ptr) {
        const instPoint *instP = basetramp_ptr->location;
        collapsedFrameAddr = instP->absPointAddr(dyninst_process->lowlevel_process());
	frame_func = instP->pointFunc();

        if(pd_debug_catchup)
           fprintf(stderr,"     PC in base tramp at 0x%lx (%s)...",
                   collapsedFrameAddr,
                   instP->pointFunc()->prettyName().c_str());
    }
    else if (reloc_ptr) {
       frame_func = reloc_ptr->func();
        collapsedFrameAddr = frame.getPC();

       if(pd_debug_catchup)
          fprintf(stderr, "      PC in relocated function (%s)...",
                  frame_func->prettyName().c_str());
    }
    else if (edge_ptr) {
      frame_func = dyninst_process->lowlevel_process()->findFuncByAddr(edge_ptr->addrInFunc);
      collapsedFrameAddr = edge_ptr->addrInFunc;
       if(pd_debug_catchup)
          fprintf(stderr, "      PC in edge tramp...");
    }
    else if (multitramp_ptr) {
        const instPoint *instP = multitramp_ptr->location;
        collapsedFrameAddr = instP->absPointAddr(dyninst_process->lowlevel_process());
	frame_func = instP->pointFunc();

        if(pd_debug_catchup)
           fprintf(stderr,"     PC in multitramp at 0x%lx (%s)...",
                   collapsedFrameAddr,
                   instP->pointFunc()->prettyName().c_str());
    }
    else {
        // Uhh... no function, no point... murph?
        // Could be top of the stack -- often address 0x0 or -1
        if (frame.getPC() && pd_debug_catchup) 
            fprintf(stderr, "     Couldn't find match for address 0x%lx!\n",
                    frame.getPC());
        return false;
    }

    if (frame_func != point->pointFunc()) {
      if(pd_debug_catchup)
         fprintf(stderr, "     Current function %s not instPoint function, returning false\n======\n",
		frame_func->prettyName().c_str());
      return false;
    }

    bool catchupNeeded = false;
    
    if (pd_debug_catchup)
      fprintf(stderr, " CFA 0x%lx, ", collapsedFrameAddr);

    if (bpPoint->getPointType() != BPatch_locLoopEntry &&
	bpPoint->getPointType() != BPatch_locLoopStartIter) {
      // We have a "collapsed" (i.e. within the function area) version
      // of the current PC. Do the same to the minitramp (instPoint/when/order)
      // passed in, and compare. 
      
      // We do handling a little differently depending on the type of inst
      // point. This takes advantage of the behavior of our inst points. So we 
      // break it up here.
      
      Address pointAddr = point->absPointAddr(dyninst_process->lowlevel_process());
      
      // addr in edge tramp then use addr which jumps to edge tramp
      if (point->addrInFunc != 0)
	pointAddr = point->addrInFunc;

      if (pd_debug_catchup)
         fprintf(stderr, "PA 0x%lx, ", pointAddr);
      
      logicalPCLocation_t location = nowhere;
      
      if (collapsedFrameAddr < pointAddr) {
        // Haven't reached the point yet
	location = beforeInstru;
      }
      else if (collapsedFrameAddr > pointAddr) {
	// If this instPoint is for function _exit_ and we're after the point, DO NOT
	// return true -- it is possible for an exit point to be in the middle of the
	// function
	location = afterInstru;
      }
      else {
	// They're both in the same point... break down further
	if (func_ptr) {
	  // We're not in a base or minitramp, but addresses match. Therefore
	  // we're at the jump to the base tramp
	  location = baseEntry;
	}
	else if (basetramp_ptr) {
	  if (frame.getPC() <= (basetramp_ptr->get_address() +
				basetramp_ptr->localPreOffset)) {
	    // From start of base tramp to beginning of instrumentation
	    location = baseEntry;
	  }
	  else if (frame.getPC() >= (basetramp_ptr->get_address() +
				     basetramp_ptr->localPreReturnOffset) &&
		   frame.getPC() <= (basetramp_ptr->get_address() +
				     basetramp_ptr->localPostOffset)) {
	    // Between pre and post...
	    location = emulInsns;
	  }
	  else if (frame.getPC() >= (basetramp_ptr->get_address() +
				     basetramp_ptr->localPostReturnOffset)) {
	    // After post
	    location = baseExit;
	  }
	  else {
	    assert(0 && "Unknown address in base tramp");
	  }
	}
	else if (minitramp_ptr) {
	  if (minitramp_ptr->when == callPreInsn) {
	    // Middle of pre instrumentation
	    location = preInsn;
	  }
	  else if (minitramp_ptr->when == callPostInsn) {
	    // Middle of post instrumentation
	    location = postInsn;
	  }
	  else
	    assert(0 && "Unknown minitramp callWhen");
	}
      } // addrs equal
      
      if (pd_debug_catchup) {
         switch(location) {
            case beforeInstru:
               fprintf(stderr, "beforeInstru...");
               break;
            case baseEntry:
               fprintf(stderr, "baseEntry...");
               break;
            case preInsn:
               fprintf(stderr, "preInsn...");
               break;
            case emulInsns:
               fprintf(stderr, "emulInsns...");
               break;
            case postInsn:
               fprintf(stderr, "postInsn...");
               break;
            case baseExit:
               fprintf(stderr, "baseExit...");
               break;
            case afterInstru:
               fprintf(stderr, "afterInstru...");
               break;
            case nowhere:
               fprintf(stderr, "serious problem with the compiler...");
               break;
         }    
      }
      // And now determine if we're before or after the point
      if (location == afterInstru) {
	// If we're looking at entry instrumentation,
	// we _want_ to do catchup -- we're in the function.
	// If we're dealing with an arbitrary point, assume that 
	// functions are linear.
	// If we're at anything else, we just missed the point
	// and don't do catchup.
	if (bpPoint->getPointType() == BPatch_locEntry)
	  catchupNeeded = true;
	else 
	  catchupNeeded = false;
      }
      // Otherwise, check by when/order/location
      else if (when == BPatch_callBefore) {
	if (order == BPatch_firstSnippet) {
	  // If we're after baseEntry, we missed it
	  catchupNeeded = (location > baseEntry);
	}
	else {
	  // If we're after preInsn, we missed it
	  catchupNeeded = (location > preInsn);
	}
      }
      else {
	// when == BPatch_callAfter
	if (order == BPatch_firstSnippet) {
	  catchupNeeded = (location > emulInsns);
	}
	else {
	  catchupNeeded = (location > postInsn);
	}
      } // callPostInsn
    }
    else {
      // LOOP CODE
      // Problem with loops is that they're non-contiguous. At least, 
      // we can't assume the easy case. So instead of a simple
      // "Before/After" split, we have an "In/Not In" split. 
      // First... get the loop body that we just instrumented.

      BPatch_basicBlockLoop *loop = bpPoint->getLoop();

      // Luckily, we can ask the loop if it contains the addr
      if (loop->containsAddressInclusive(collapsedFrameAddr))
	catchupNeeded = true;
      else
	catchupNeeded = false;
    }
      

    if (pd_debug_catchup) {
       if (catchupNeeded)
          fprintf(stderr, "catchup needed, ret true\n========\n");
       else
          fprintf(stderr, "catchup not needed, ret false\n=======\n");
    }
#endif
    bool catchupNeeded = false;
    return catchupNeeded;
}

#endif

bool pd_process::walkStacks(pdvector<BPatch_Vector<BPatch_frame> > &stackWalks) {
    bool success = true;
    for (threadMgr::thrIter iter = thr_mgr.begin();
         iter != thr_mgr.end();
         iter++) {
        BPatch_Vector<BPatch_frame> walk;
        if (!(*iter)->walkStack(walk))
            success = false;
        stackWalks.push_back(walk);
    }
    return success;
}

BPatch_Vector<BPatch_function *> *pd_process::getIncludedFunctions(BPatch_module *mod)
{
    if (!img) return NULL;
    return img->getIncludedFunctions(mod);
}


BPatch_Vector<BPatch_function *> *pd_process::getIncludedFunctions()
{
   if (!img) return NULL;
   return img->getIncludedFunctions();
}

pdvector<BPatch_module *> *pd_process::getIncludedModules(pdvector<BPatch_module *> *buf)
{
   if (!img) return buf;
   return img->getIncludedModules(buf);
}

BPatch_module *pd_process::findModule(const pdstring &mod_name,bool check_excluded)
{
   if (!img) return NULL;
   return img->findModule(mod_name, check_excluded);

}

bool pd_process::installInstrRequests(const pdvector<pdinstMapping*> &requests)
{
  BPatch_image *appImage = img->get_dyn_image();
  BPatch_process *appProc = get_dyn_process();
  bool err = false;

  for (unsigned i = 0; i < requests.size(); ++i) {
    pdinstMapping *req = requests[i];

    if (!multithread_capable() && req->is_MTonly())
       continue;
   
    //  used to split the func name into lib and func in some cases,
    //  not sure this is necessary anymore.
    BPatch_Vector<BPatch_function *> bpfv;
    if (!appImage->findFunction(req->func.c_str(), bpfv, !req->quiet_fail)
        || !bpfv.size()) {
      if (!req->quiet_fail) {
        fprintf(stderr, "%s[%d]:  cannot find function %s, instrRequest skipped\n",
               __FILE__, __LINE__, req->func.c_str());
      }
      err = true;
      continue;
    }    
    for (unsigned int j = 0; j < bpfv.size(); ++j) {
      BPatch_function *bpf = bpfv[j];
      if (!bpf) {
        fprintf(stderr, "%s[%d]:  BAD NEWS, got NULL BPatch_function for %s\n",
                __FILE__, __LINE__, req->func.c_str());
        err = true;
        continue;
      }
      BPatch_Vector<BPatch_function *> bpfv2;
      if (!appImage->findFunction(req->inst.c_str(), bpfv2)
          || !bpfv2.size()) {
         if (!req->quiet_fail)
           fprintf(stderr, "%s[%d]:  cannot find function %s, instrRequest skipped\n",
                   __FILE__, __LINE__, req->inst.c_str());
         err = true;
         continue;
      }
      if (bpfv2.size() > 1) {
        if (!req->quiet_fail)
          fprintf(stderr, "%s[%d]: %d matches for function %s, using the first\n",
                 __FILE__, __LINE__, bpfv2.size(), req->inst.c_str());
      }
      BPatch_function *bpf_inst = bpfv2[0];
      BPatch_snippet *snip;

      if ((req->where & FUNC_ARG) && req->args.size()) {
         snip = new BPatch_funcCallExpr(*bpf_inst, req->args);
      } else {
         BPatch_constExpr *tmp = new BPatch_constExpr(0);
         BPatch_Vector<BPatch_snippet *> tmp_args;
         tmp_args.push_back(tmp);
         snip = new BPatch_funcCallExpr(*bpf_inst, tmp_args);
         delete tmp; // is this safe ?
      }

      if (req->where & FUNC_EXIT) {
         BPatch_Vector<BPatch_point *> *exit_points = bpf->findPoint(BPatch_exit);
         if ((!exit_points) || !exit_points->size()) {
           if (!req->quiet_fail)
             fprintf(stderr, "%s[%d]:  function %s has no exit points, %s\n",
                     __FILE__, __LINE__, req->func.c_str(),
                     "cannot perform instrumentation request.");
           err = true;
         }
         else {
           for (unsigned k = 0; k < exit_points->size(); ++k) {
             BPatch_point *exit_pt = (*exit_points)[k];
             BPatchSnippetHandle *snipHandle;
             //  allow_trap is always true with insertSnippet
             //  useTrampGuard is generally controlled by BPatch::isTrampRecursive
             snipHandle = appProc->insertSnippet(*snip, *exit_pt,
                                                   req->when, req->order);
             if (NULL == snipHandle) {
               //  this request failed, but keep going...
               //  QUESTION:  should we add the NULL to req->snippetHandles so that
               //  a 1-1 mapping between requests and results is maintained?
               //if (!req->quiet_fail) 
                 fprintf(stderr, "%s[%d]:  failed to insert inst request for %s exit\n",
                        __FILE__, __LINE__, req->func.c_str());
               err = true;
             }
             else {
               //  add returned handle to the request class and keep going...
               req->snippetHandles.push_back(snipHandle);
             }
           } // for k
        }
      }

      if (req->where & FUNC_ENTRY) {
         BPatch_Vector<BPatch_point *> *entry_points = bpf->findPoint(BPatch_entry);
         if ((!entry_points) || !entry_points->size()) {
           if (!req->quiet_fail) 
             fprintf(stderr, "%s[%d]:  function %s has no entry points, %s\n",
                     __FILE__, __LINE__, req->func.c_str(),
                     "cannot perform instrumentation request.");
           err = true;
         }
         else {
           BPatch_point *entry_pt = (*entry_points)[0];
           BPatchSnippetHandle *snipHandle;
           //  allow_trap is always true with insertSnippet
           //  useTrampGuard is generally controlled by BPatch::isTrampRecursive
           snipHandle = appProc->insertSnippet(*snip, *entry_pt,
                                                 req->when, req->order);
           if (NULL == snipHandle) {
             //  this request failed, but keep going...
             //  QUESTION:  should we add the NULL to req->snippetHandles so that
             //  a 1-1 mapping between requests and results is maintained?
             if (!req->quiet_fail)
               fprintf(stderr, "%s[%d]:  failed to insert inst request for %s entry\n",
                      __FILE__, __LINE__, req->func.c_str());
             err = true;
           }
           else {
             //  add returned handle to the request class and keep going...
             req->snippetHandles.push_back(snipHandle);
           }
        }
      }

      if (req->where & FUNC_CALL) {
         BPatch_Vector<BPatch_point *> *call_points = bpf->findPoint(BPatch_subroutine);
         if ((!call_points) || !call_points->size()) {
           if (!req->quiet_fail)
             fprintf(stderr, "%s[%d]:  function %s has no call points, %s\n",
                     __FILE__, __LINE__, req->func.c_str(),
                     "cannot perform instrumentation request.");
           err = true;
         }
         else {
           for (unsigned k = 0; k < call_points->size(); ++k) {
             BPatch_point *call_pt = (*call_points)[k];
             BPatchSnippetHandle *snipHandle;
             //  allow_trap is always true with insertSnippet
             //  useTrampGuard is generally controlled by BPatch::isTrampRecursive
             snipHandle = appProc->insertSnippet(*snip, *call_pt,
                                                   req->when, req->order);
             if (NULL == snipHandle) {
               //  this request failed, but keep going...
               //  QUESTION:  should we add the NULL to req->snippetHandles so that
               //  a 1-1 mapping between requests and results is maintained?
               if (!req->quiet_fail)
                 fprintf(stderr, "%s[%d]:  failed to insert inst request for %s call (%s)\n",
                        __FILE__, __LINE__, req->func.c_str(), req->inst.c_str());
               err = true;
             }
             else {
               //  add returned handle to the request class and keep going...
               req->snippetHandles.push_back(snipHandle);
             }
           } // for k
        }
      }

      delete snip;
    } // for j
  } // for i

  return err;
}

bool pd_process::findAllFuncsByName(resource *func, resource *mod,
                           BPatch_Vector<BPatch_function *> &res) {
     const pdvector<pdstring> &f_names = func->names();
     const pdvector<pdstring> &m_names = mod->names();
     pdstring func_name = f_names[f_names.size() -1];
     pdstring mod_name = m_names[m_names.size() -1];
     BPatch_Vector<BPatch_module *> *mods = dyninst_process->getImage()->getModules();
     assert(mods);
     for (unsigned int i = 0; i < mods->size(); ++i) {
       char nbuf[512];
       (*mods)[i]->getName(nbuf, 512);
       if (!strcmp(nbuf, mod_name.c_str())) {
         BPatch_module *target_mod = (*mods)[i];
         BPatch_Vector<BPatch_function *> modfuncs;
         if (NULL == target_mod->findFunction(func_name.c_str(), res, 
                                              false, false, true, true)
            || !res.size()) {
            return false;
         }
         return true;
       }
     }

     BPatch_image *appImage = dyninst_process->getImage();
     if (NULL == appImage->findFunction(func_name.c_str(), res, false)
        || !res.size()) {
          //fprintf(stderr, "%s[%d]: function %s not found in image\n",
          //        __FILE__, __LINE__, func_name.c_str());
       return false;
     }
     return true;
}

bool pd_process::isStopped() const {return dyninst_process->isStopped();}
bool pd_process::isTerminated() const {return dyninst_process->isTerminated();}
bool pd_process::isDetached() const {return dyninst_process->isDetached();}
bool pd_process::continueProc() {
    return dyninst_process->continueExecution();
}
bool pd_process::pauseProc() 
{
    if (!dyninst_process->stopExecution())
        return false;
    if (dyninst_process->isTerminated())
        return false;

  return true;
}

/**
 * Dyninst calls this function when a new thread is found
 **/
void pd_process::pdNewThread(BPatch_process *proc, BPatch_thread *thr)
{
   pd_process *pd_proc = NULL;
   processMgr::procIter itr = getProcMgr().begin();
   for (; itr != getProcMgr().end(); itr++)
   {
      if ((*itr)->get_dyn_process() == proc)
      {
         pd_proc = *itr;
         break;
      }
   }
   if( ! pd_proc ) {
     /* We're still creating the pd_process (e.g., MPI startup) when
        Dyninst notices the initial thread. */
     return;
     }

   int thread_id = thr->getTid();

   pd_thread *foundThr = pd_proc->findThread(thread_id);
   if(foundThr) {
      // received a duplicate thread create, can happen if rpcs launched on
      // lwps of a MT forked off child process get run on same threads, since
      // lwps changed between threads
      return;
   }

   // Ignore new threads until initialization is finished.  We'll manually
   // create everything then.
   //   if (paradynRTState < libLoaded)
   //   return;

   //Create pd_thread object


   pd_thread *pd_thr = new pd_thread(thr, pd_proc);

   pd_proc->addThread(pd_thr);

	 //We don't report resources yet if these are the initial threads, but we do
	 // if we find them during runtime
	 if (pd_proc->canReportResources())
		 pd_proc->reportOneThread(pd_thr);
}

void pd_process::reportOneThread(pd_thread *pd_thr)
{
	metricFocusNode::handleNewThread(this, pd_thr);
		 
	//Create new resource for this thread
	pdstring buffer = pdstring("thr_") + pdstring(itos(pd_thr->get_tid())) + 
		pdstring("{") + pd_thr->get_initial_func_name() + pdstring("}");
	resource *rid = resource::newResource(get_rid(),
                                         (void *) pd_thr,
                                         nullString, 
                                         buffer,
                                         timeStamp::ts1970(),
                                         "",
                                         ThreadResourceType,
                                         MDL_T_STRING,
                                         false);

   

   pd_thr->update_rid(rid);
   unsigned index = pd_thr->get_index();
   pd_thr->resetInferiorVtime(this->getVirtualTimer(index));  

   // tell front-end about thread start function for newly created threads
   BPatch_function *initial_func = pd_thr->get_dyn_thread()->getInitialFunc();
   resource *funcRes = pd_module::getFunctionResource(initial_func);
   pdstring full_res_name(funcRes->full_name());
   rid->send_now();
   CallGraphSetEntryFuncCallback(this->getImage()->get_file(), full_res_name,
																pd_thr->get_tid());   
}

void pd_process::reportInitialThreads()
{
   if (!this->multithread_capable())
      return;

	 threadMgr::thrIter itr = beginThr();
	 for (; itr != endThrMark(); itr++) {
		 pd_thread *pd_thr = *itr;
		 reportOneThread(pd_thr);
	 }
}

/**
 * Dyninst calls this function when a thread is destroyed
 **/
void pd_process::pdDeadThread(BPatch_process *proc, BPatch_thread *thr)
{
   pd_process *pdproc = NULL;
	 assert(theProcMgr);
   processMgr::procIter itr = getProcMgr().begin();
   for (; itr != getProcMgr().end(); itr++)
   {
      pdproc = *itr;
      if (!pdproc) continue;
      if (pdproc->get_dyn_process() == proc) break;
      pdproc = NULL;
   }
   if (!pdproc)
      return;

   pd_thread *pdthr = pdproc->findThread(thr->getTid());
   if (!pdthr)
      return;

   pdproc->removeThread(pdthr);

   delete pdthr;
}

void pd_process::findThreads()
{
   BPatch_Vector<BPatch_thread *> thrds;
   dyninst_process->getThreads(thrds);
   
   for (unsigned i=0; i<thrds.size(); i++)
   {
      pdNewThread(dyninst_process, thrds[i]);
   }
}

void pd_process::report_CallGraphChecksumToFE( void )
{

	//fprintf(stderr, "[%s:%u] - At top of pd_process::report_CallGraphChecksumToFE\n", __FILE__, __LINE__);
	 // TODO: make checksumtype global
    extern unsigned sdm_id;
    extern MRN::Stream * equivClassReportStream;

    resource::ChecksumType checksum = calculateCallGraphChecksum();

    //checksum calculated, send to FE
    pdvector<T_dyninstRPC::equiv_class_entry> entries;
    T_dyninstRPC::equiv_class_entry entry;

    entry.val = checksum;
    entry.class_rep = sdm_id;
    entries.push_back( entry );

    tp->callGraphEquivClassReportCallback( equivClassReportStream,entries );
}

resource::ChecksumType pd_process::calculateCallGraphChecksum()
{
    processMgr::procIter itr = getProcMgr().begin();
    assert( itr != getProcMgr().end()); 

    pdstring graph = " ";
    unsigned checksum = 0;

    pd_process *p = *itr++;
    assert(p);
    p->FillInCallGraphStatic(true, &checksum);
		
    return(checksum);
}

unsigned pd_process::calculate_Checksum( pdstring graph)
{
    resource::ChecksumType ret = 0;


    const pdstring& fname = graph;
 
    const unsigned* curr = (const unsigned*)(fname.c_str());
    unsigned int nFullElements = fname.length() / sizeof(unsigned);
    unsigned int nLeftoverBytes = fname.length() - 
                                    nFullElements * sizeof(unsigned); 
    for( unsigned int i = 0; i < nFullElements; i++ )
    {
        ret += *curr;
        curr++;
    }
    // Add in the leftover bytes.
    // We have to be careful here, because we have no guarantee that we
    // can access the addresses following the pdstring.  Instead, we copy
    // bytes into a separate location and add it into the sum.
    unsigned leftovers = 0;
    for( unsigned int j = 0; j < nLeftoverBytes; j++ )
    {
        memcpy( &leftovers, curr, nLeftoverBytes );
    }
    ret += leftovers;

    return ret;
}

unsigned pd_process::postRPCtoDo(BPatch_snippet &action, bool noCost,
                                 BPatchOneTimeCodeCallback callbackFunc,
                                 void *userData, 
                                 bool runWhenFinished,
                                 bool lowmem,
                                 BPatch_thread *thr) 
{
    unsigned retval = (unsigned)-1;

    if (NULL == callbackFunc) {
       bool otc_err = false;
       void *return_value = thr->oneTimeCode(action, &otc_err);
       if (otc_err) {
         fprintf(stderr, "%s[%d]:  oneTimeCode failed\n", FILE__, __LINE__);
       }
       else
         retval = 0;
    }
    else {
       fprintf(stderr, "%s[%d]:  FIXME:  check oneTimeCode callback mapping\n", FILE__, __LINE__);
       //  need to ensure that this callback is properly associated with this oneTimeCode
       bool ok = thr->oneTimeCodeAsync(action, userData, callbackFunc);
       if (!ok) {
         fprintf(stderr, "%s[%d]:  oneTimeCodeAsync failed\n", FILE__, __LINE__);
       }
       else
         retval = 0;
    }

    return retval;
}

unsigned long pd_process::getOSHandle() 
{
    if (!os_handle)
        initOSHandle();
    return os_handle;
}

void pd_process::initOSHandle() 
{
    os_handle = dyninst_process->getPid();
#if defined(os_windows)
    os_handle = (unsigned long) OpenProcess(PROCESS_ALL_ACCESS, false, os_handle);
#endif
}

void pd_process::closeOSHandle() 
{
#if defined(os_windows)
    if (os_handle)
        CloseHandle((HANDLE) os_handle);
#endif
}
