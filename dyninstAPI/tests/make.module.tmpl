# 
# Common makefile template for dyninst Tests.  This file is not intended to
# be a useful Makefile in isolation; instead, it should be included
# from within an architecture-specific Makefile.
#
# $Id: make.module.tmpl,v 1.57 2004/04/20 01:27:55 jaw Exp $
#

SUITE_NAME	= Dyninst
RELEASE_NUM	= 4.0
#BUILD_MARK should be (re-)defined in core/make.config.local rather than here!

DEST		= $(TO_CORE)/$(PROGRAM_DEST)/testprogs

# Test to see if GCC is available
ifdef M_GCC
OUTPUT		= $(shell $(M_GCC) --version)
ifeq (,$(findstring GCC,$(OUTPUT)))
M_GCC =
endif
endif

# Test to see if GXX is available
ifdef M_GXX
OUTPUT		= $(shell $(M_GXX) --version)
ifeq (,$(findstring GCC,$(OUTPUT)))
M_GXX =
endif
endif

ifdef TARGET
SRCS	     += ../src/$(TARGET).C ../src/test_util.C
else
TARGETS       =  test1 test2 test3 test4 test5 test6 test7 test8 test9 test10 test11
ifdef M_GCC
TARGETS      +=	 test1.mutatee_$(M_GCC) \
		 test2.mutatee_$(M_GCC) \
		 test3.mutatee_$(M_GCC) \
		 test4a.mutatee_$(M_GCC) \
		 test4b.mutatee_$(M_GCC) \
		 test6.mutatee_$(M_GCC) \
		 test7.mutatee_$(M_GCC) \
		 test8.mutatee_$(M_GCC) \
		 test9.mutatee_$(M_GCC) \
		 test10.mutatee_$(M_GCC)
endif

ifdef NATIVE_CC
TARGETS      +=  test1.mutatee_$(NATIVE_CC) \
		 test2.mutatee_$(NATIVE_CC) \
		 test3.mutatee_$(NATIVE_CC) \
		 test4a.mutatee_$(NATIVE_CC) \
		 test4b.mutatee_$(NATIVE_CC) \
		 test6.mutatee_$(NATIVE_CC) \
		 test7.mutatee_$(NATIVE_CC) \
		 test8.mutatee_$(NATIVE_CC) \
		 test9.mutatee_$(NATIVE_CC)

endif

ifdef M_GXX	
TARGETS      +=  test1.mutatee_$(M_GXX) \
		 test2.mutatee_$(M_GXX) \
		 test3.mutatee_$(M_GXX) \
		 test4a.mutatee_$(M_GXX) \
		 test4b.mutatee_$(M_GXX) \
		 test5.mutatee_$(M_GXX) \
		 test7.mutatee_$(M_GXX) \
		 test8.mutatee_$(M_GXX) \
		 test9.mutatee_$(M_GXX)

endif

ifdef NATIVE_CXX

USES_NATIVE_CC  =   true

ifeq ($(DEBUG_FLAG),-gstabs+)
DEBUG_FLAG =
endif

TARGETS      +=  test1.mutatee_$(NATIVE_CXX) \
		 test2.mutatee_$(NATIVE_CXX) \
		 test3.mutatee_$(NATIVE_CXX) \
		 test4a.mutatee_$(NATIVE_CXX) \
		 test4b.mutatee_$(NATIVE_CXX) \
		 test5.mutatee_$(NATIVE_CXX) \
		 test7.mutatee_$(NATIVE_CXX) \
		 test8.mutatee_$(NATIVE_CXX) \
		 test9.mutatee_$(NATIVE_CXX)

endif

ifdef NATIVE_FC
TARGETS      +=  test1.mutatee_$(NATIVE_FC)
endif

SRCS	     += ../src/test1.C ../src/test1.mutatee.c ../src/test_util.C \
		../src/test2.C ../src/test2.mutatee.c \
		../src/test3.C ../src/test3.mutatee.c \
		../src/test4.C ../src/test4a.mutatee.c ../src/test4b.mutatee.c \
		../src/test5.C ../src/test5.mutatee.C \
		../src/test6.C \
		../src/test7.C \
		../src/test8.C ../src/test8.mutatee.c \
		../src/test9.C ../src/test9.mutatee.c \
		../src/test10.C ../src/test10.mutatee.c\
                ../src/libtestA.c ../src/libtestB.c \
		../src/libLoadMe.c  ../src/libInstMe.c 
endif

ifdef NATIVE_FC
SRCS         += ../src/test1.mutateeFort.F
endif

# Libraries for dlopen tests
#TARGETS      += libtestA.so libtestB.so

ifndef MUTATEE_SUFFIX
MUTATEE_SUFFIX=.c
endif

MUTATEE_SRC = ../src/$(TARGET2:_$(MUTATEE_CC)=$(MUTATEE_SUFFIX))

# test1 has some extra files
ifeq (test1.mutatee, $(findstring test1.mutatee, $(TARGET2)))
MUTATEE_SRC += ../src/test1.mutateeCommon.c ../src/mutatee_util.c
endif

# test8 uses mutatee_util.c
ifeq (test8.mutatee, $(findstring test8.mutatee, $(TARGET2)))
MUTATEE_SRC += ../src/mutatee_util.c
endif

# add special rules for test6 assembler stuff in a generic way
# define MINI_PLATFORM, TEST6_ASFLAGS and TEST6_ASSUFFIX in the Makefile that includes this
ifeq (test6,$(findstring test6,$(TARGET2)))
TEST6_AS_SRC	=	test6LS-$(MINI_PLATFORM).$(TEST6_ASSUFFIX)
endif

# For gcc (which may use gas) we force the native assembler with TEST6_ASFLAGS
ifeq (test6,$(findstring test6,$(TARGET2)))
TEST6_AS_OBJ	= 	$(TEST6_AS_SRC:.$(TEST6_ASSUFFIX)=.o)
MUTATEE_SRC     +=      $(TEST6_AS_OBJ)

test6.mutatee_$(M_GCC):	$(TEST6_AS_OBJ)
test6.mutatee_pgcc:	$(TEST6_AS_OBJ)

$(TEST6_AS_OBJ):	../src/$(TEST6_AS_SRC)
ifeq (linux,$(findstring linux,$(PLATFORM)))
ifdef NASM
	$(NASM) $(TEST6_ASFLAGS) -o $@ $<
else
	$(AS) $(TEST6_ASFLAGS) -o $@ $<
endif
else
	$(AS) $(TEST6_ASFLAGS) -o $@ $<
endif
endif

#$(warning MUTATEE_SRC: $(MUTATEE_SRC))

VPATH	     +=

ifdef GCC_2_95
CXXFLAGS     += -I../../h $(BASICWARNINGS) -fno-squangle
FORT_SQGL_FLAG = -fno-squangle
else
CXXFLAGS     += -I../../h $(BASICWARNINGS)
FORT_SQGL_FLAG =
endif
CFLAGS       += -I../../h $(BASICWARNINGS)

LIBS         += -ldyninstAPI

ifdef IBM_BPATCH_COMPAT
ifeq (aix,$(findstring aix,$(PLATFORM)))
LIBS         += -liberty
endif
endif #IBM_BPATCH_COMPAT

ifndef USES_NATIVE_CC
SYSLIBS      += -liberty
PICOP        = -fpic
SHAREDOP     = -shared
else
ifeq (solaris,$(findstring solaris,$(PLATFORM)))
SYSLIBS      += -ldemangle
PICOP        = -Kpic
SHAREDOP     = -G
endif
endif

# don't bother to do this in a make aTest submake...
ifndef MUTATEE_CC

# We need this hack to avoid tests being maked twice by the top level
# Paradyn makefile (once by make all and a second time by make
# install). Such invocations break test6. We still want to be able to
# do incremental development builds, so we have different a rule if
# not invoked recursively.  Because the list of dependencies for
# tests.done would be too complex, we use this simpler hack:
ifeq (0,$(MAKELEVEL))
all:
else
all:	tests.done

tests.done:
endif
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test1
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test2
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test3
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test4
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test5
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test6
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test7
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test8
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test9
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test10
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET=test11
	$(MAKE) testlibs MUTATEE_CC=$(M_GCC)

ifneq ($(M_GCC),)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test1.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test2.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test3.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test4a.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test4b.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test6.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test7.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test8.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test9.mutatee_$(M_GCC)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) TARGET2=test10.mutatee_$(M_GCC)
else
	@echo "WARNING: Skipping gcc mutatees..."
endif
ifneq ($(NATIVE_CC),)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test1.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test2.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test3.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test4a.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test4b.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test6.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test7.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test8.mutatee_$(NATIVE_CC)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CC) TARGET2=test9.mutatee_$(NATIVE_CC)
else
	@echo "WARNING: Skipping native C compiler mutatees..."
endif
ifneq ($(M_GXX),)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test1.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test2.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test3.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test4a.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test4b.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test5.mutatee_$(M_GXX) MUTATEE_SUFFIX=.C
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test7.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test8.mutatee_$(M_GXX)
	$(MAKE) aTest MUTATEE_CC=$(M_GXX) TARGET2=test9.mutatee_$(M_GXX)
else
	@echo "WARNING: Skipping g++ mutatees..."
endif
ifneq ($(NATIVE_CXX),)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test1.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test2.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test3.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test4a.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test4b.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test5.mutatee_$(NATIVE_CXX) MUTATEE_SUFFIX=.C
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test7.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test8.mutatee_$(NATIVE_CXX)
	$(MAKE) aTest MUTATEE_CC=$(NATIVE_CXX) TARGET2=test9.mutatee_$(NATIVE_CXX)
else
	@echo "WARNING: Skipping native C++ compiler mutatees..."
endif
ifneq ($(NATIVE_FC),)
	$(MAKE) aTest MUTATEE_CC=$(M_GCC) MUTATEE_FC=$(NATIVE_FC) TARGET2=test1.mutatee_$(NATIVE_FC)
else
	@echo "WARNING: Skipping Fortran compiler mutatees..."
endif
	touch tests.done
endif

pc:
	$(MAKE) purecov TARGET=test1 TARGET2=test1.mutatee
	$(MAKE) purecov TARGET=test2 TARGET2=test2.mutatee

aTest:	$(TARGET) $(TARGET2)

# Explicit test11 build instruction.
test11:
	cp ../src/test11.sh test11

testlibs: libtestA.so libtestB.so $(MUTATEE_TEST9_LIBS_LIST)

# test1.mutatee uses dlopen for replaceFunction tests
# (currently only implemented on SPARC/Solaris and Alpha/Tru64)
# It also uses it for detach-on-the-fly on Linux.
ifeq (test1,$(findstring test1,$(TARGET2)))
ifdef USES_MUTATEE_LIBS
MUTLIBS=$(MUTATEE_LIBS)
endif
endif
# test2.mutatee uses dlopen to force a dynamic object load
ifeq (test2,$(findstring test2,$(TARGET2)))
MUTLIBS=$(MUTATEE_LIBS)
endif
ifeq (test5,$(findstring test5,$(TARGET2)))
MUTLIBS=$(MUTATEE_LIBS)
endif
ifeq (test8,$(findstring test8,$(TARGET2)))
MUTLIBS=$(MUTATEE_LIBS)
endif

# test9.mutatee used libInstMe.so
ifeq (test9,$(findstring test9,$(TARGET2)))
ifdef MUTATEE_TEST9_LIBS 
MUTLIBS=$(MUTATEE_TEST9_LIBS)
endif
endif

UNCOMMON_INSTALL=true

install: all
	-@$(MKDIR) $(DEST)
	-$(CP) $(TARGETS) $(DEST)

clean::
	rm -f *.da *.bb *.bbg libtestA.so libtestB.so tests.done libInstMe.so libLoadMe.so
