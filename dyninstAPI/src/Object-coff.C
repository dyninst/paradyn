/*
 * Copyright (c) 1996 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

// $Id: Object-coff.C,v 1.6 2000/03/09 16:30:31 hollings Exp $

#include "util/h/Dictionary.h"
#include "dyninstAPI/src/Object.h"
#include "dyninstAPI/src/Object-coff.h"

bool GCC_COMPILED=false; //Used to detect compiler type. True if mutatee is 
			 //compiled with a GNU compiler. parseCoff.C needs this

char *ScName(int sc) {
static char scBuf[20];

	switch(sc) {
	case scNil:
		strcpy(scBuf, "scNil");
		break;
	case scText:
		strcpy(scBuf, "scText");
		break;
	case scData:
		strcpy(scBuf, "scData");
		break;
	case scBss:
		strcpy(scBuf, "scBss");
		break;
	case scRegister:
		strcpy(scBuf, "scRegister");
		break;
	case scAbs:
		strcpy(scBuf, "scAbs");
		break;
	case scUndefined:
		strcpy(scBuf, "scUndefined");
		break;
	case scUnallocated:
		strcpy(scBuf, "scUnallocated");
		break;
	case scBits:
		strcpy(scBuf, "scBits");
		break;
	case scTlsUndefined:
		strcpy(scBuf, "scTlsUndefined");
		break;
	case scRegImage:
		strcpy(scBuf, "scRegImage");
		break;
	case scInfo:
		strcpy(scBuf, "scInfo");
		break;
	case scUserStruct:
		strcpy(scBuf, "scUserStruct");
		break;
	case scSData:
		strcpy(scBuf, "scSData");
		break;
	case scSBss:
		strcpy(scBuf, "scSBss");
		break;
	case scRData:
		strcpy(scBuf, "scRData");
		break;
	case scVar:
		strcpy(scBuf, "scVar");
		break;
	case scCommon:
		strcpy(scBuf, "scCommon");
		break;
	case scSCommon:
		strcpy(scBuf, "scSCommon");
		break;
	case scVarRegister:
		strcpy(scBuf, "scVarRegister");
		break;
	case scVariant:
		strcpy(scBuf, "scVariant");
		break;
	case scSUndefined:
		strcpy(scBuf, "scSUndefined");
		break;
	case scInit:
		strcpy(scBuf, "scInit");
		break;
	case scBasedVar:
		strcpy(scBuf, "scBasedVar");
		break;
	case scXData:
		strcpy(scBuf, "scXData");
		break;
	case scPData:
		strcpy(scBuf, "scPData");
		break;
	case scFini:
		strcpy(scBuf, "scFini");
		break;
	case scRConst:
		strcpy(scBuf, "scRConst");
		break;
	case scSymRef:
		strcpy(scBuf, "scSymRef");
		break;
	case scTlsCommon:
		strcpy(scBuf, "scTlsCommon");
		break;
	case scTlsData:
		strcpy(scBuf, "scTlsData");
		break;
	case scTlsBss:
		strcpy(scBuf, "scTlsBss");
		break;
	default:
		strcpy(scBuf,"Wrong Sc");
		break;
	}

	return scBuf;
}

char *StName(int st) {
static char stBuf[20];

	switch(st) {
	case stNil:
		strcpy(stBuf, "stNil");
		break;
	case stGlobal:
		strcpy(stBuf, "stGlobal");
		break;
	case stStatic:
		strcpy(stBuf, "stStatic");
		break;
	case stParam:
		strcpy(stBuf, "stParam");
		break;
	case stLocal:
		strcpy(stBuf, "stLocal");
		break;
	case stLabel:
		strcpy(stBuf, "stLabel");
		break;
	case stProc:
		strcpy(stBuf, "stProc");
		break;
	case stBlock:
		strcpy(stBuf, "stBlock");
		break;
	case stEnd:
		strcpy(stBuf, "stEnd");
		break;
	case stMember:
		strcpy(stBuf, "stMember");
		break;
	case stTypedef:
		strcpy(stBuf, "stTypedef");
		break;
	case stFile:
		strcpy(stBuf, "stFile");
		break;
	case stRegReloc:
		strcpy(stBuf, "stRegReloc");
		break;
	case stForward:
		strcpy(stBuf, "stForward");
		break;
	case stStaticProc:
		strcpy(stBuf, "stStaticProc");
		break;
	case stConstant:
		strcpy(stBuf, "stConstant");
		break;
	case stStaParam:
		strcpy(stBuf, "stStaParam");
		break;
	case stBase:
		strcpy(stBuf, "stBase");
		break;
	case stVirtBase:
		strcpy(stBuf, "stVirtBase");
		break;
	case stTag:
		strcpy(stBuf, "stTag");
		break;
	case stInter:
		strcpy(stBuf, "stInter");
		break;
	case stSplit:
		strcpy(stBuf, "stSplit");
		break;
	case stModule:
		strcpy(stBuf, "stModule");
		break;
	case stModview:
		strcpy(stBuf, "stModview");
		break;
	case stAlias:
		strcpy(stBuf, "stAlias");
		break;
	case stStr:
		strcpy(stBuf, "stStr");
		break;
	case stNumber:
		strcpy(stBuf, "stNumber");
		break;
	case stExpr:
		strcpy(stBuf, "stExpr");
		break;
	case stType:
		strcpy(stBuf, "stType");
		break;
	default:
		strcpy(stBuf, "Wrong st");
		break;
	}

	return stBuf;
}


static inline bool obj_read_section(SCNHDR& secthead, LDFILE *ldptr,
				    Word *buffer) {
  if (!secthead.s_scnptr) return false;
  if (ldfseek(ldptr, secthead.s_scnptr, SEEK_SET) == -1) return false;

  if (ldfread((void*) buffer, 1, secthead.s_size, ldptr) != secthead.s_size)
    return false;
  else
    return true;
}

// The possible data sections
// These should only be used locally
#define K_D_INDEX    0
#define K_XD_INDEX   1
#define K_PD_INDEX   2
#define K_SD_INDEX   3
#define K_RD_INDEX   4
#define K_RC_INDEX   5 
#define K_L4_INDEX   6
#define K_L8_INDEX   7
#define K_LA_INDEX   8

// Attempt to find the largest contiguous (in virtual address space) region.
// This region must include ".data", and may include the other data like regions
static inline bool find_data_region(vector<Address>& all_addr,
				    vector<long>& all_size,
				    vector<long>& all_disk,
				    unsigned long& data_len, Address& data_off) {
  // Start at data and work back
  assert(all_addr[K_D_INDEX]); assert(all_size[K_D_INDEX]);
  assert(all_addr.size() == all_size.size());

  Address current = all_addr[K_D_INDEX];
  Address min_adr = current;
  Address max_adr = current + all_size[K_D_INDEX];

  unsigned index, max=all_addr.size();

  bool updated=true;
  while (updated) {
    updated = false;
    for (index=0; index<max; index++) {
      if (all_addr[index] && all_size[index] && all_disk[index] &&
	  ((all_addr[index] + all_size[index]) == current)) {
	current = all_addr[index];
	updated = true;
      }
    }
  }
  min_adr = current;

  // Start at data and work forward
  current = max_adr;
  updated=true;
  while (updated) {
    updated = false;
    for (index=0; index<max; index++) {
      if (all_addr[index] && all_size[index] && all_disk[index] && 
	  (all_addr[index] == current)) {
	current = all_addr[index] + all_size[index];
	updated = true;
      }
    }
  }

  max_adr = current;
  
  data_len = (max_adr - min_adr) / sizeof(Word);
  data_off = min_adr;
  assert(min_adr <= all_addr[K_D_INDEX]);
  assert(max_adr >= all_addr[K_D_INDEX] + all_size[K_D_INDEX]);
  return true;
}

// Read in from the contiguous data regions, put the data in 'buffer'
static inline bool read_data_region(vector<Address>& all_addr,
				    vector<long>& all_size,
				    vector<long>& all_disk,
				    unsigned long& data_len, Address& data_off,
				    Word *buffer, LDFILE *ldptr) {
  unsigned index, max = all_disk.size();
  Address max_adr = data_off + data_len * sizeof(Word);
  assert(all_size.size() == all_addr.size());
  assert(all_disk.size() == all_addr.size());
  for (index=0; index<max; index++) {
    if ((all_addr[index] >= data_off) &&
	((all_addr[index] + all_size[index]) <= max_adr)) {
      if (ldfseek(ldptr, all_disk[index], SEEK_SET) == -1) return false;
      Word *buf_temp = buffer + ((all_addr[index] - data_off) / sizeof(Word));
      if (ldfread((void*) buf_temp, 1, all_size[index], ldptr) != all_size[index])
	return false;
    }
  }
  return true;
}

void Object::load_object(bool sharedLibrary) {
    char* file = strdup(file_.string_of());
    bool        did_open = false, success=true, text_read=false;
    LDFILE      *ldptr = NULL;
    HDRR        sym_hdr;
    pCHDRR      sym_tab_ptr = NULL;
    long        index=0;
    SYMR        symbol;
    unsigned short sectindex=1;
    SCNHDR      secthead;
    filehdr     fhdr;
    unsigned 	nsymbols;
    vector<Symbol> allSymbols;
    vector<Address> all_addr(9, 0);
    vector<long> all_size(9, 0);
    vector<bool> all_dex(9, false);
    vector<long> all_disk(9, 0);

        if (!(ldptr = ldopen(file, ldptr))) {
            log_perror(err_func_, file);
	    success = false;
	    printf("failed open\n");
	    free(file);
	    return;
        }
        did_open = true;

	if (TYPE(ldptr) != ALPHAMAGIC) {
	    log_printf(err_func_, "%s is not an alpha executable\n", file);
	    success = false;
	    printf("failed magic region\n");
	    ldclose(ldptr);
	    free(file);
	    return;
        }

	// Read the text and data sections
	fhdr = HEADER(ldptr);
	unsigned short fmax = fhdr.f_nscns;

	dynamicallyLinked = false;

	// Life would be so much easier if there were a guaranteed order for
	// these sections.  But the man page makes no mention of it.
	while (sectindex < fmax) {
	  if (ldshread(ldptr, sectindex, &secthead) == SUCCESS) {
	    // cout << "Section: " << secthead.s_name << "\tStart: " << secthead.s_vaddr 
	    // << "\tEnd: " << secthead.s_vaddr + secthead.s_size << endl;

	    if (!P_strcmp(secthead.s_name, ".text")) {
	      code_len_ = Word(secthead.s_size >> LOG_WORD);
	      Word *buffer = new Word[code_len_+1];
	      code_ptr_ = buffer;
	      code_off_ = (Address) secthead.s_vaddr;
	      if (!obj_read_section(secthead, ldptr, buffer)) {
		success = false;
		printf("failed text region\n");
		ldclose(ldptr);
		free(file);
		return;
	      }
	      text_read = true;
	    } else if (!P_strcmp(secthead.s_name, ".data")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_D_INDEX] = secthead.s_vaddr;
		all_size[K_D_INDEX] = secthead.s_size;
		all_dex[K_D_INDEX] = true;
		all_disk[K_D_INDEX] = secthead.s_scnptr;
	      } else {
		printf("failed data region\n");
		success = false;
		ldclose(ldptr);
		free(file);
		return;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".xdata")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_XD_INDEX] = secthead.s_vaddr;
		all_size[K_XD_INDEX] = secthead.s_size;
		all_dex[K_XD_INDEX] = true;
		all_disk[K_XD_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".sdata")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_SD_INDEX] = secthead.s_vaddr;
		all_size[K_SD_INDEX] = secthead.s_size;
		all_dex[K_SD_INDEX] = true;
		all_disk[K_SD_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".rdata")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_RD_INDEX] = secthead.s_vaddr;
		all_size[K_RD_INDEX] = secthead.s_size;
		all_dex[K_RD_INDEX] = true;
		all_disk[K_RD_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".lit4")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_L4_INDEX] = secthead.s_vaddr;
		all_size[K_L4_INDEX] = secthead.s_size;
		all_dex[K_L4_INDEX] = true;
		all_disk[K_L4_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".lita")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_LA_INDEX] = secthead.s_vaddr;
		all_size[K_LA_INDEX] = secthead.s_size;
		all_dex[K_LA_INDEX] = true;
		all_disk[K_LA_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".rconst")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_RC_INDEX] = secthead.s_vaddr;
		all_size[K_RC_INDEX] = secthead.s_size;
		all_dex[K_RC_INDEX] = true;
		all_disk[K_RC_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strcmp(secthead.s_name, ".lit8")) {
	      if (secthead.s_vaddr && secthead.s_scnptr) {
		all_addr[K_L8_INDEX] = secthead.s_vaddr;
		all_size[K_L8_INDEX] = secthead.s_size;
		all_dex[K_L8_INDEX] = true;
		all_disk[K_L8_INDEX] = secthead.s_scnptr;
	      }
	    } else if (!P_strncmp(secthead.s_name, ".dynamic", 8)) {
	      // a section .dynamic implies the program is dynamically linked
	      dynamicallyLinked = true; 
	    }
	  } else {
	    success = false;
	    printf("failed header region\n");
	    ldclose(ldptr);
	    free(file);
	    return;
	  }
	  sectindex++;
	}

	if (!text_read) { 
	  success = false;
	  printf("failed text region\n");
	  ldclose(ldptr);
	  free(file);
	  return;
	}

	// I am assuming that .data comes before all other data sections
	// I will include all other contiguous data sections
	// Determine the size of the data section(s)
	if (all_disk[K_D_INDEX]) {
	    if (!find_data_region(all_addr, all_size, all_disk,data_len_,data_off_)) {
	      success = false;
	      printf("failed find data region\n");
	      ldclose(ldptr);
	      free(file);
	      return;
	    }
	}

	// Now read in the data from the assorted data regions
	Word *buffer = new Word[data_len_+1];
	data_ptr_ = buffer;
	if (!read_data_region(all_addr, all_size, all_disk,
			      data_len_, data_off_, buffer, ldptr)) {
	  success = false;
	  ldclose(ldptr);
	  free(file);
	  return;
	}

	// Read the symbol table
	sym_hdr = SYMHEADER(ldptr);
	if (sym_hdr.magic != magicSym) {
	    success = false;
	    ldclose(ldptr);
	    free(file);
	    return;
        }
	if (!(sym_tab_ptr = SYMTAB(ldptr))) {
	    success = false;
	    ldclose(ldptr);
	    free(file);
	    return;
	}
	if (LDSWAP(ldptr)) {
	  // These bytes are swapped
	  // supposedly libsex.a will unswap them
	  assert(0);
	}

	string module = "DEFAULT_MODULE";
        if (sharedLibrary) {
	    module = file_;
	    allSymbols += Symbol(module, module, Symbol::PDST_MODULE, 
		Symbol::SL_GLOBAL, (Address) 0, false);
	} else {
	    module = "DEFAULT_MODULE";
	}

        string        name   = "DEFAULT_SYMBOL";
	int moduleEndIdx = -1;
	dictionary_hash<string, int> fcnNames(string::hash);

	while (ldtbread(ldptr, index, &symbol) == SUCCESS) {
	  // TODO -- when global?
	  Symbol::SymbolLinkage linkage = Symbol::SL_GLOBAL;
	  Symbol::SymbolType type = Symbol::PDST_UNKNOWN;
	  bool st_kludge = false;
	  bool sym_use = true;
	  char *name = ldgetname(ldptr, &symbol);

	switch(symbol.st) {
	case stProc:
	case stStaticProc:
		if (symbol.sc == scText && !fcnNames.defines(name)) {
			type = Symbol::PDST_FUNCTION;
			fcnNames[name] = 1;
		}
		else 
			sym_use = false;
		break;

	case stGlobal:
	case stConstant:
	case stStatic:
		switch(symbol.sc) {
		case scData:
		case scSData:
		case scBss:
		case scSBss:
		case scRData:
		case scRConst:
		case scTlsData:
		case scTlsBss:
			type = Symbol::PDST_OBJECT;
			break;
		default:
			sym_use = false;
		}
		break;

	case stLocal:
	case stParam:
		linkage = Symbol::SL_LOCAL;

		switch(symbol.sc) {
		case scAbs:
		case scRegister:
		case scVar:
		case scVarRegister:
		case scUnallocated:
			type = Symbol::PDST_OBJECT;
			break;

		case scData:
		case scSData:
		case scBss:
		case scSBss:
		case scRConst:
		case scRData:
			 //Parameter is static var. Don't know what to do
			if (symbol.st == stParam)
				type = Symbol::PDST_OBJECT;
			else
				sym_use = false;
			break;

		default:
			sym_use = false;
		}
		break;

	case stTypedef:
	case stBase: //Base class
	case stTag: //C++ class, structure or union
		if (symbol.sc == scInfo)
			type = Symbol::PDST_OBJECT;
		else
			sym_use = false;
		break;

	case stFile:
		if (!sharedLibrary) {
			module = ldgetname(ldptr, &symbol); assert(module.length());
			type   = Symbol::PDST_MODULE;
			moduleEndIdx = symbol.index - 1;
			//Detect the compiler type by searching libgcc.
			if (strstr(module.string_of(), "libgcc"))
				GCC_COMPILED = true;
		}
		break;

	case stEnd:
		if (index == moduleEndIdx)
			module = "DEFAULT_MODULE";
		sym_use = false;
		break;

	default:
		sym_use = false;
	}

	  // cout << index << "\t" << name << "\t" << StName(symbol.st) << "\t" << ScName(symbol.sc) << "\t" << symbol.value << "\n";

	  index++;

	  if (sym_use) {
	    // cout << index << "\t" << module << "\t" << name << "\t" << type << "\t" << symbol.value << "\n";
	    allSymbols += Symbol(name, module, type, linkage,
				      (Address) symbol.value, st_kludge);
	  }

    } //while

    allSymbols.sort(symbol_compare);
    // find the function boundaries
    nsymbols = allSymbols.size();

    //Insert global symbols
    for (unsigned u = 0; u < nsymbols; u++) {
	unsigned size = 0;
	if (allSymbols[u].type() == Symbol::PDST_FUNCTION) {
	    unsigned v = u+1;
	    while (v < nsymbols) {
		// The .ef below is a special symbol that gcc puts in to
                // mark the end of a function.
                if (allSymbols[v].addr() != allSymbols[u].addr() &&
                      (allSymbols[v].type() == Symbol::PDST_FUNCTION ||
                       allSymbols[v].name() == ".ef"))
                break;
                v++;
            }
	    if (v < nsymbols) {
                  size = (unsigned)allSymbols[v].addr()
                         - (unsigned)allSymbols[u].addr();
	    } else {
                  size = (unsigned)(code_off_+code_len_*sizeof(Word))
                         - (unsigned)allSymbols[u].addr();
	    }
	}
	
	if (allSymbols[u].linkage() != Symbol::SL_LOCAL) {
		symbols_[allSymbols[u].name()] =
	   		Symbol(allSymbols[u].name(), allSymbols[u].module(), 
	      		allSymbols[u].type(), allSymbols[u].linkage(), 
	       		allSymbols[u].addr(), allSymbols[u].kludge(), size);
	}
    }

    //Insert local symbols (Do we need this?)
    for (unsigned u = 0; u < nsymbols; u++) {
	if ( (allSymbols[u].linkage() == Symbol::SL_LOCAL) &&
		(!symbols_.defines(allSymbols[u].name())) ) {
		symbols_[allSymbols[u].name()] =
	   		Symbol(allSymbols[u].name(), allSymbols[u].module(), 
	      		allSymbols[u].type(), allSymbols[u].linkage(), 
	       		allSymbols[u].addr(), allSymbols[u].kludge(), 0);
	}
    }
		
    if (did_open && (ldclose(ldptr) == FAILURE)) {
        log_perror(err_func_, "close");
    }
    free(file);
}


Object::Object(const string file, void (*err_func)(const char *))
    : AObject(file, err_func) {
    load_object(false);
}

/* 
 * Called to init a shared library.
 */
Object::Object (const string fileName, const Address /*BaseAddr*/,
        void (*err_func)(const char *) = log_msg)
  :AObject(fileName,err_func)
{

  load_object(true);

}

inline
Object::Object(const Object& obj)
    : AObject(obj) {
    load_object(false);
}

