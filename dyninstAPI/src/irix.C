/*
 * Copyright (c) 1998 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

// $Id: irix.C,v 1.11 1999/10/29 22:32:32 zandy Exp $

#include <sys/types.h>    // procfs
#include <sys/signal.h>   // procfs
#include <sys/fault.h>    // procfs
#include <sys/syscall.h>  // procfs
#include <sys/procfs.h>   // procfs
#include <unistd.h>       // getpid()
#include <sys/ucontext.h> // gregset_t
#include "dyninstAPI/src/arch-mips.h"
#include "dyninstAPI/src/inst-mips.h"
#include "dyninstAPI/src/symtab.h" // pd_Function
#include "dyninstAPI/src/instPoint-mips.h"
#include "dyninstAPI/src/instP.h"
#include "dyninstAPI/src/process.h"
#include "dyninstAPI/src/stats.h" // ptrace{Ops,Bytes}
#include "util/h/pathName.h" // expand_tilde_pathname, exists_executable
#include "util/h/irixKludges.h" // PDYN_XXX
#include <limits.h>       // poll()
#include <stropts.h>      // poll()
#include <poll.h>         // poll()
#include <errno.h>        // errno
#include <stdio.h>        // perror()
#include <sys/sysmp.h>    // sysmp()
#include <sys/sysinfo.h>  // sysmp()
#include <string.h>       // strncmp()
#include <stdlib.h>       // getenv()
#include <termio.h>       // TIOCNOTTY
#include <sys/timers.h>   // PTIMER macros


extern debug_ostream inferiorrpc_cerr;

extern char *Bool[];
void print_proc_flags(int fd)
{
  prstatus stat;
  ioctl(fd, PIOCSTATUS, &stat);
  fprintf(stderr, "flags: ");

  if (stat.pr_flags & PR_STOPPED) fprintf(stderr, "PR_STOPPED ");
  if (stat.pr_flags & PR_ISTOP) fprintf(stderr, "PR_ISTOP ");
  if (stat.pr_flags & PR_DSTOP) fprintf(stderr, "PR_DSTOP ");
  if (stat.pr_flags & PR_STEP) fprintf(stderr, "PR_STEP ");
  if (stat.pr_flags & PR_ASLEEP) fprintf(stderr, "PR_ASLEEP ");
  if (stat.pr_flags & PR_PCINVAL) fprintf(stderr, "PR_PCINVAL ");
  //if (stat.pr_flags & PR_ISSYS) fprintf(stderr, "PR_ISSYS ");
  if (stat.pr_flags & PR_FORK) fprintf(stderr, "PR_FORK ");
  if (stat.pr_flags & PR_RLC) fprintf(stderr, "PR_RLC ");
  if (stat.pr_flags & PR_KLC) fprintf(stderr, "PR_KLC ");
  if (stat.pr_flags & PR_PTRACE) fprintf(stderr, "PR_PTRACE ");

  if (stat.pr_flags & PR_ISKTHREAD) fprintf(stderr, "PR_ISKTHREAD ");
  if (stat.pr_flags & PR_JOINTSTOP) fprintf(stderr, "PR_JOINTSTOP ");
  if (stat.pr_flags & PR_JOINTPOLL) fprintf(stderr, "PR_JOINTPOLL ");
  if (stat.pr_flags & PR_RETURN) fprintf(stderr, "PR_RETURN ");
  if (stat.pr_flags & PR_CKF) fprintf(stderr, "PR_CKF ");

  fprintf(stderr, "\n");
}

void print_proc_regs(int fd)
{
  gregset_t regs;
  if (ioctl (fd, PIOCGREG, &regs) == -1) {
    perror("ioctl(PIOCGREG)");
    return;
  }
  char buf[32];
  for (int i = 0; i < 32; i++) {
    sprintf(buf, "$%s", reg_names[i]);
    fprintf(stderr, "%5s: %#10x %s", buf, (unsigned)regs[i],
	    (i % 4 == 3) ? ("\n") : (","));
  }
  fprintf(stderr, "%5s: %#10x\n", "$pc", (unsigned)regs[CTX_EPC]);
}

void print_proc_pc(int fd)
{
  gregset_t regs;
  if (ioctl (fd, PIOCGREG, &regs) == -1) {
    perror("ioctl(PIOCGREG)");
    return;
  }
  fprintf(stderr, "%5s: %#10x\n", "$pc", (unsigned)regs[CTX_EPC]);
}

bool process::readDataSpace_(const void *inTraced, u_int nbytes, void *inSelf)
{
  //fprintf(stderr, ">>> process::readDataSpace_(0x%016lx)\n", inTraced);
  ptraceOps++; 
  ptraceBytes += nbytes;

  if(lseek(proc_fd, (off_t)inTraced, SEEK_SET) == -1) {
    perror("process::readDataSpace_(lseek)");
    return false;
  }

  // TODO: check for infinite loop if read returns 0?
  char *dst = (char *)inSelf;
  for (int last, left = nbytes; left > 0; left -= last) {
    if ((last = read(proc_fd, dst + nbytes - left, left)) == -1) {
      perror("process::readDataSpace_(read)");
      return false;
    }
  }
  return true;
}

bool process::writeDataSpace_(void *inTraced, u_int nbytes, const void *inSelf)
{
  //fprintf(stderr, ">>> process::writeDataSpace_(0x%08x: %i bytes)\n", inTraced, nbytes);
  ptraceOps++; 
  ptraceBytes += nbytes;

  if(lseek(proc_fd, (off_t)inTraced, SEEK_SET) == -1) {
    perror("process::writeDataSpace_(lseek)");
    return false;
  }

  // TODO: check for infinite loop if write returns 0?
 char *src = (char *)const_cast<void*>(inSelf);
  for (int last, left = nbytes; left > 0; left -= last) {
    if ((last = write(proc_fd, src + nbytes - left, left)) == -1) {
      perror("process::writeDataSpace_(write)");
      return false;
    }
  }
  return true;
}

bool process::writeTextWord_(caddr_t inTraced, int data)
{
  //fprintf(stderr, ">>> process::writeTextWord_()\n");
  return writeDataSpace_(inTraced, INSN_SIZE, &data);
}

bool process::writeTextSpace_(void *inTraced, u_int amount, const void *inSelf)
{
  //fprintf(stderr, ">>> process::writeTextSpace_()\n");
  return writeDataSpace_(inTraced, amount, inSelf);
}

#ifdef BPATCH_SET_MUTATIONS_ACTIVE
bool process::readTextSpace_(void *inTraced, u_int amount, const void *inSelf)
{
  //fprintf(stderr, ">>> process::readTextSpace_()\n");
  return readDataSpace_(inTraced, amount, (void *)inSelf);
}
#endif

void *process::getRegisters() 
{
  //fprintf(stderr, ">>> process::getRegisters()\n");
  assert(status_ == stopped); // process must be stopped (procfs)
  
  gregset_t intRegs;
  if (ioctl(proc_fd, PIOCGREG, &intRegs) == -1) {
    perror("process::getRegisters(PIOCGREG)");
    assert(errno != EBUSY); // procfs thinks the process is active
    return NULL;
  }
  fpregset_t fpRegs;
  if (ioctl(proc_fd, PIOCGFPREG, &fpRegs) == -1) {
    perror("process::getRegisters(PIOCGFPREG)");
    assert(errno != EBUSY);  // procfs thinks the process is active
    assert(errno != EINVAL); // no floating-point hardware
    return NULL;
  }
  
  char *buf = new char[sizeof(intRegs) + sizeof(fpRegs)];
  assert(buf);
  memcpy(buf, &intRegs, sizeof(intRegs));
  memcpy(buf + sizeof(intRegs), &fpRegs, sizeof(fpRegs));
  
  return (void *)buf;
}

bool process::restoreRegisters(void *_buf)
{
  //fprintf(stderr, ">>> process::restoreRegisters()\n");
  assert(status_ == stopped); // process must be stopped (procfs)

  char *buf = (char *)_buf;
  gregset_t *intRegs = (gregset_t *)buf;
  if (ioctl(proc_fd, PIOCSREG, intRegs) == -1) {
    perror("process::restoreRegisters(PIOCSREG)");
    assert(errno != EBUSY); // procfs thinks the process is active
    return false;
  }  
  fpregset_t *fpRegs = (fpregset_t *)(buf + sizeof(gregset_t));
  if (ioctl(proc_fd, PIOCSFPREG, fpRegs) == -1) {
    perror("process::restoreRegisters(PIOCSFPREG)");
    assert(errno != EBUSY);  // procfs thinks the process is active
    assert(errno != EINVAL); // no floating-point hardware
    return false;
  }

  return true;
}

// fetch actual PC value via procfs
// TODO: make "process::" - csserra
Address pcFromProc(int proc_fd)
{
  gregset_t regs;
  if (ioctl (proc_fd, PIOCGREG, &regs) == -1) {
    perror("currentPC(PIOCGREG)");
    assert(errno != EBUSY); // procfs thinks the process is active
    return 0;
  }
  return (Address)regs[PROC_REG_PC];
}

bool process::changePC(Address addr, const void *savedRegs)
{
  //fprintf(stderr, ">>> process::changePC(0x%08x)\n", addr);
  assert(status_ == stopped); // process must be stopped (procfs)

  /* copy integer registers from register buffer */
  gregset_t *savedIntRegs = (gregset_t *)const_cast<void*>(savedRegs); 
  gregset_t intRegs;
  memcpy(&intRegs, savedIntRegs, sizeof(gregset_t));

  intRegs[PROC_REG_PC] = addr; // set PC

  if (ioctl(proc_fd, PIOCSREG, &intRegs) == -1) {
    perror("process::changePC(PIOCSREG)");
    assert(errno != EBUSY); // procfs thinks the process is active
    return false;
  }

   return true;
}

bool process::changePC(Address addr)
{
  //fprintf(stderr, ">>> process::changePC()\n");
  assert(status_ == stopped); // process must be stopped (procfs)

  gregset_t intRegs;
  if (ioctl(proc_fd, PIOCGREG, &intRegs) == -1) {
    perror("process::changePC(PIOCGREG)");
    assert(errno != EBUSY); // procfs thinks the process is active
    return false;
  }

  intRegs[PROC_REG_PC] = addr; // set PC

  if (ioctl(proc_fd, PIOCSREG, &intRegs) == -1) {
    perror("process::changePC(PIOCSREG)");
    assert(errno != EBUSY); // procfs thinks the process is active
    return false;
  }

   return true;
}

bool process::isRunning_() const
{
  //fprintf(stderr, ">>> process::isRunning_()\n");
  prstatus status;
  if (ioctl(proc_fd, PIOCSTATUS, &status) == -1) {
    perror("process::isRunning_()");
    assert(0);
  }

  // TODO - check for discrepancy with "status_" member?
  if (status.pr_flags & PR_STOPPED) return false;

  return true;
}

void OS::osTraceMe(void)
{
  char procName[128];
  sprintf(procName,"/proc/%05d", (int)getpid());
  //fprintf(stderr, ">>> OS::osTraceMe(%s)\n", procName);
  int fd = P_open(procName, O_RDWR, 0);
  if (fd < 0) {
    fprintf(stderr, "osTraceMe: open failed: %s\n", sys_errlist[errno]); 
    fflush(stderr);
    P__exit(-1); // must use _exit here.
  }

  // Procfs on Irix sets the "run-on-last-close" flag (PR_RLC) by default.
  // This flag needs to be unset to avoid the PIOCSEXIT trace (below) from
  // being lost when the child closes the proc file descriptor to itself.
  /* reset "run-on-last-close" flag */
  long flags = PR_RLC;
  if (ioctl(fd, PIOCRESET, &flags) < 0) {
    fprintf(stderr, "osTraceMe: PIOCRESET failed: %s\n", sys_errlist[errno]); 
    fflush(stderr);
    P__exit(-1); // must use _exit here.
  };

  /* set a breakpoint at the exit of execv/execve */
  sysset_t exitSet;
  premptyset(&exitSet);
  (void)praddset(&exitSet, SYS_execv);
  (void)praddset(&exitSet, SYS_execve);
  if (ioctl(fd, PIOCSEXIT, &exitSet) < 0) {
    fprintf(stderr, "osTraceMe: PIOCSEXIT failed: %s\n", sys_errlist[errno]); 
    fflush(stderr);
    P__exit(-1); // must use _exit here.
  }

  errno = 0;
  close(fd);
}

bool process::attach()
{
  // QUESTION: does this attach operation lead to a SIGTRAP being forwarded
  // to paradynd in all cases?  How about when we are attaching to an
  // already-running process?  (Seems that in the latter case, no SIGTRAP
  // is automatically generated) TODO

  // step 1 - /proc open: attach to the inferior process
  char procName[128];
  sprintf(procName,"/proc/%05d", (int)pid);
  int fd = P_open(procName, O_RDWR, 0);
  if (fd < 0) {
    // TODO: official error msg for API tests
    //perror("process::attach(open)");
    return false;
  }

  // step 2 - /proc PIOCSTRACE: define which signals should be forwarded to daemon
  // these are (1) SIGSTOP and (2) either SIGTRAP (sparc/mips) or SIGILL (x86),
  // to implement inferiorRPC completion detection.
  sigset_t sigs;
  premptyset(&sigs);
  (void)praddset(&sigs, SIGSTOP);
  (void)praddset(&sigs, SIGTRAP);
  (void)praddset(&sigs, SIGILL);
  if (ioctl(fd, PIOCSTRACE, &sigs) < 0) {
    perror("process::attach(PIOCSTRACE)");
    close(fd);
    return false;
  }

  // step 3 - /proc PIOC{SET,RESET}:
  // a) turn on the kill-on-last-close flag (kills inferior with SIGKILL when
  //    the last writable /proc fd closes)
  // b) turn on inherit-on-fork flag (tracing flags inherited when
  // child forks), Paradyn only.
  // c) turn off run-on-last-close flag (on by default)
  // Also, any child of this process will stop at the exit of an exec
  // call, Paradyn only.
  long flags = 0;
  /* FIXME: When fork/exec callbacks are implemented for Dyninst, set
     PR_FORK for Dyninst, too.  It is not set now because otherwise
     the child would inherit trap-on-exit from exec.  With no way for
     a mutator to handle this stop, the child process would remain
     stopped indefinitely. */
#ifndef BPATCH_LIBRARY
  flags = PR_KLC | PR_FORK;
#endif
  if (ioctl (fd, PIOCSET, &flags) < 0) {
    perror("process::attach(PIOCSET)");
    close(fd);
    return false;
  }
  flags = PR_RLC;
  if (ioctl (fd, PIOCRESET, &flags) < 0) {
    perror("process::attach(PIOCRESET)");
    close(fd);
    return false;
  }

  proc_fd = fd;

  // environment variables
  prpsinfo_t info;
  if (ioctl(fd, PIOCPSINFO, &info) < 0) {
    perror("process::attach(PIOCPSINFO)");
    close(fd);
    return false;
  }
  // argv[0]
  char *argv0_start = info.pr_psargs;
  char *argv0_end = strstr(argv0_start, " ");
  if (argv0_end) (*argv0_end) = 0;
  argv0 = argv0_start;
  // unused variables
  pathenv = "";
  cwdenv = "";

  return true;
}

#ifdef BPATCH_LIBRARY
int process::waitProcs(int *status, bool block)
#else
int process::waitProcs(int *status)
#endif
{
  //fprintf(stderr, ">>> process::waitProcs()\n");

  extern vector<process*> processVec;

  static struct pollfd fds[OPEN_MAX];  // argument for poll
  static int selected_fds;             // number of selected
  static int curr;                     // the current element of fds

#ifdef BPATCH_LIBRARY
  do {
#endif
    
    /* Each call to poll may return many selected fds. Since we only
       report the status of one process per each call to waitProcs, we
       keep the result of the last poll buffered, and simply process an
       element from the buffer until all of the selected fds in the
       last poll have been processed.  
    */
    
    if (selected_fds == 0) {
      for (unsigned i = 0; i < processVec.size(); i++) {
	if (processVec[i] && 
	    (processVec[i]->status() == running || processVec[i]->status() == neonatal))
	  fds[i].fd = processVec[i]->proc_fd;
	else
	  fds[i].fd = -1;
	fds[i].events = POLLPRI;
	fds[i].revents = 0;
      }
      
#ifdef BPATCH_LIBRARY
      int timeout;
      if (block) timeout = INFTIM;
      else timeout = 0;
      selected_fds = poll(fds, processVec.size(), timeout);
#else
      selected_fds = poll(fds, processVec.size(), 0);
#endif
      if (selected_fds == -1) {
	perror("process::waitProcs(poll)");
	selected_fds = 0;
	return 0;
      }      
      curr = 0;
    }
    
    if (selected_fds > 0) {
      while (fds[curr].revents == 0) curr++;
      // fds[curr] has an event of interest
      //fprintf(stderr, ">>> process::waitProcs(fd %i)\n", curr);

      prstatus_t stat;
      int ret = 0;
#ifdef BPATCH_LIBRARY
      if (fds[curr].revents & POLLHUP) {
	//fprintf(stderr, ">>> process::waitProcs(fd %i): POLLHUP\n", curr);
	do {
	  ret = waitpid(processVec[curr]->getPid(), status, 0);
	} while ((ret < 0) && (errno == EINTR));
	if (ret < 0) {
	  // This means that the application exited, but was not our child
	  // so it didn't wait around for us to get it's return code.  In
	  // this case, we can't know why it exited or what it's return
	  // code was.
	  ret = processVec[curr]->getPid();
	  *status = 0;
	}
	assert(ret == processVec[curr]->getPid());
      } else
#endif
	if (ioctl(fds[curr].fd, PIOCSTATUS, &stat) != -1 
	    && ((stat.pr_flags & PR_STOPPED) || (stat.pr_flags & PR_ISTOP))) {
	  //print_proc_flags(fds[curr].fd);
	  process *p = processVec[curr];
	  switch (stat.pr_why) {
	  case PR_SIGNALLED: {
	    // debug
	    //fprintf(stderr, ">>> process::waitProcs(fd %i): $pc(0x%08x), sig(%i)\n", 
	    //curr, stat.pr_reg[PROC_REG_PC], stat.pr_what);

	    // return the signal number
	    *status = stat.pr_what << 8 | 0177;
	    ret = p->getPid();
#if defined(USES_LIBDYNINSTRT_SO)
	    if (!p->dyninstLibAlreadyLoaded() && 
		p->wasCreatedViaAttach()) 
	      {
		// make sure we are stopped in the eyes of paradynd - naim
		bool wasRunning = (p->status() == running);
		if (p->status() != stopped) p->Stopped();   

		// check for dlopen() of libdyninstRT.so.1
		if(p->isDynamicallyLinked()) {
		  bool objectWasMapped = p->handleIfDueToSharedObjectMapping();
		  if (p->dyninstLibAlreadyLoaded()) {
		    // libdyninstRT.so.1 was just loaded so cleanup "_start"
		    assert(objectWasMapped);
		    p->handleIfDueToDyninstLib();
		  }
		}
		if (wasRunning) {
		  assert(p->continueProc());
		}
	      }
#endif
	  } break;
	  case PR_SYSEXIT: {
	    //fprintf(stderr, ">>> process::waitProcs(fd %i): PR_SYSEXIT\n", curr);
	    // exit of a system call
	    if (p->RPCs_waiting_for_syscall_to_complete) {
	      // reset PIOCSEXIT mask
	      //inferiorrpc_cerr << "solaris got PR_SYSEXIT!" << endl;
	      assert(p->save_exitset_ptr != NULL);
	      assert(ioctl(p->proc_fd, PIOCSEXIT, p->save_exitset_ptr) != -1);
	      delete [] p->save_exitset_ptr;
	      p->save_exitset_ptr = NULL;
	      // fall through on purpose (so status, ret get set)
	    }
	    else if (stat.pr_reg[PROC_REG_RV] != 0) {
	      // a failed exec; continue the process
	      p->continueProc_();
	      break;
	    }          
	    *status = SIGTRAP << 8 | 0177;
	    ret = p->getPid();
	    break;
	  }
	  case PR_REQUESTED:
	    // TODO: this has been reached
	    fprintf(stderr, ">>> process::waitProcs(fd %i): PR_REQUESTED\n", curr);
	    assert(0);
	  case PR_JOBCONTROL:
	    fprintf(stderr, ">>> process::waitProcs(fd %i): PR_JOBCONTROL\n", curr);
	    assert(0);
	    break;
	  }        
	}
      
      --selected_fds;
      ++curr;      
      if (ret > 0) return ret;
    }
#ifdef BPATCH_LIBRARY
  } while (block);
  return 0;
#else
  return waitpid(0, status, WNOHANG);
#endif
}

bool process::detach_()
{
  //fprintf(stderr, ">>> process::detach_()\n");
  if (close(proc_fd) == -1) {
    perror("process::detach_(close)");
    return false;
  }
  return true;
}

bool process::continueProc_()
{
  //fprintf(stderr, ">>> process::continueProc_()\n");
  ptraceOps++; 
  ptraceOtherOps++;

  prstatus_t stat;
  if (ioctl(proc_fd, PIOCSTATUS, &stat) == -1) {
    perror("process::continueProc_(PIOCSTATUS)");
    return false;
  }

  if (!(stat.pr_flags & (PR_STOPPED | PR_ISTOP))) {
    // not stopped
    fprintf(stderr, "continueProc_(): process not stopped\n");
    print_proc_flags(proc_fd);
    return false;
  }
  
  prrun_t run;
  run.pr_flags = PRCSIG; // clear current signal
  if (hasNewPC) {        // new PC value
    hasNewPC = false;
    run.pr_vaddr = (caddr_t)currentPC_;
    run.pr_flags |= PRSVADDR;
  }
  if (ioctl(proc_fd, PIOCRUN, &run) == -1) {
    perror("process::continueProc_(PIOCRUN)");
    return false;
  }

  return true;
}

bool process::heapIsOk(const vector<sym_data>&findUs)
{
  if (!(mainFunction = findOneFunction("main")) &&
      !(mainFunction = findOneFunction("_main"))) {
    fprintf(stderr, "process::heapIsOk(): failed to find \"main\"\n");
    return false;
  }

  for (unsigned i = 0; i < findUs.size(); i++) {
    const string &name = findUs[i].name;
    Address addr = lookup_fn(this, name);
    if (!addr && findUs[i].must_find) {
      fprintf(stderr, "process::heapIsOk(): failed to find \"%s\"\n", name.string_of());
      return false;
    }
  }

  string heap_name = INFERIOR_HEAP_BASE;
  Address heap_addr = lookup_fn(this, heap_name);
  if (!heap_addr) {
    fprintf(stderr, "process::heapIsOk(): failed to find \"%s\"\n", heap_name.string_of());
    return false;
  }

  return true;
}

bool process::executingSystemCall()
{
   bool ret = false;
   prstatus stat;
   if (ioctl(proc_fd, PIOCSTATUS, &stat) == -1) {
     perror("process::executingSystemCall(PIOCSTATUS)");
     assert(0);
   }
   if (stat.pr_syscall > 0) {
     inferiorrpc_cerr << "pr_syscall=" << stat.pr_syscall << endl;
     ret = true;
   }
   return ret;
}

Address process::read_inferiorRPC_result_register(Register retval_reg)
{
  //fprintf(stderr, ">>> process::read_inferiorRPC_result_register()\n");
  gregset_t regs;
  if (ioctl (proc_fd, PIOCGREG, &regs) == -1) {
    perror("process::_inferiorRPC_result_registerread(PIOCGREG)");
    return 0;
  }
  return regs[retval_reg];
}

static const Address lowest_addr = 0x00400000;
void inferiorMallocConstraints(Address near, Address &lo, Address &hi)
{
  lo = region_lo(near);
  hi = region_hi(near);  
  // avoid mapping the zero page
  if (lo < lowest_addr) lo = lowest_addr;
}

void inferiorMallocAlign(unsigned &size)
{
  // quadword-aligned (stack alignment)
  unsigned align = 16;
  if (size % align) size = ((size/align)+1)*align;
}

bool process::pause_()
{
  //fprintf(stderr, ">>> process::pause_()\n");
  ptraceOps++; 
  ptraceOtherOps++;

  int ret;
  if ((ret = ioctl(proc_fd, PIOCSTOP, 0)) == -1) {
    perror("process::pause_(PIOCSTOP)");
    sprintf(errorLine, "warning: PIOCSTOP failed in \"pause_\", errno=%i\n", errno);
    logLine(errorLine);
  }

  return (ret != -1);
}

int getNumberOfCPUs() 
{
  // see sysmp(2) man page
  int ret = sysmp(MP_NPROCS);
  //fprintf(stderr, ">>> getNumberOfCPUs(%i)\n", ret);
  return ret;
}

bool process::set_breakpoint_for_syscall_completion()
{
  /* Can assume: (1) process is paused and (2) in a system call.  We
     want to set a TRAP for the syscall exit, and do the inferiorRPC
     at that time.  We'll use /proc PIOCSEXIT.  Returns true iff
     breakpoint was successfully set. */
  //fprintf(stderr, ">>> process::set_breakpoint_for_syscall_completion()\n");
  
  sysset_t save_exitset;
  if (ioctl(proc_fd, PIOCGEXIT, &save_exitset) == -1) {
    return false;
  }
  
  sysset_t new_exitset;
  prfillset(&new_exitset);
  if (ioctl(proc_fd, PIOCSEXIT, &new_exitset) == -1) {
    return false;
  }
  
  assert(save_exitset_ptr == NULL);
  save_exitset_ptr = new sysset_t;
  memcpy(save_exitset_ptr, &save_exitset, sizeof(sysset_t));
  
  return true;
}

void process::clear_breakpoint_for_syscall_completion() { return; }

// TODO: this ignores the "sig" argument
bool process::continueWithForwardSignal(int /*sig*/)
{
  fprintf(stderr, ">>> process::continueWithForwardSignal()\n");
  if (ioctl(proc_fd, PIOCRUN, NULL) == -1) {
    perror("process::continueWithForwardSignal(PIOCRUN)\n");
    return false;
  }
  return true;
}

bool process::dumpCore_(const string coreFile)
{
  //fprintf(stderr, ">>> process::dumpCore_()\n");
  bool ret;
#ifdef BPATCH_LIBRARY
  ret = dumpImage(coreFile);
#else
  ret = dumpImage();
#endif
  return ret;
}

#ifdef BPATCH_LIBRARY
bool process::terminateProc_()
{
  //fprintf(stderr, ">>> process::terminateProc_()\n");
  long flags = PR_KLC;
  if (ioctl(proc_fd, PIOCSET, &flags) == -1) {
    // not an error: proc_fd has probably been close()ed already
    return false;
  }  
  Exited();
  return true;
}
#endif

#ifdef BPATCH_LIBRARY
/* API_detach_: detach from the process (clean up /proc state);
   continue process' execution if "cont" is true. */
bool process::API_detach_(const bool cont)
{
  //fprintf(stderr, ">>> process::API_detach_(%s)\n", (cont) ? ("continue") : ("abort"));
  bool ret = true;

  // remove shared object loading traps
  if (dyn) dyn->unsetMappingHooks(this);

  // signal handling
  sigset_t sigs;
  premptyset(&sigs);
  if (ioctl(proc_fd, PIOCSTRACE, &sigs) == -1) {
    //perror("process::API_detach_(PIOCSTRACE)");
    ret = false;
  }
  if (ioctl(proc_fd, PIOCSHOLD, &sigs) == -1) {
    //perror("process::API_detach_(PIOCSHOLD)");
    ret = false;
  }
  // fault handling
  fltset_t faults;
  premptyset(&faults);
  if (ioctl(proc_fd, PIOCSFAULT, &faults) == -1) {
    //perror("process::API_detach_(PIOCSFAULT)");
    ret = false;
  }
  // system call handling
  sysset_t syscalls;
  premptyset(&syscalls);
  if (ioctl(proc_fd, PIOCSENTRY, &syscalls) == -1) {
    //perror("process::API_detach_(PIOCSENTRY)");
    ret = false;
  }
  if (ioctl(proc_fd, PIOCSEXIT, &syscalls) == -1) {
    //perror("process::API_detach_(PIOCSEXIT)");
    ret = false;
  }
  // operation mode
  long flags = PR_RLC | PR_KLC;
  if (ioctl(proc_fd, PIOCRESET, &flags) == -1) {
    //perror("process::API_detach_(PIOCRESET)");
    ret = false;
  }
  flags = (cont) ? (PR_RLC) : (PR_KLC);
  if (ioctl(proc_fd, PIOCSET, &flags) == -1) {
    //perror("process::API_detach_(PIOCSET)");
    ret = false;
  }    

  close(proc_fd);
  return ret;
}
#endif

string process::tryToFindExecutable(const string &progpath, int /*pid*/)
{
  //fprintf(stderr, ">>> process::tryToFindExecutable(%s)\n", progpath.string_of());
  string ret = "";
  
  // attempt #1: expand_tilde_pathname()
  ret = expand_tilde_pathname(progpath);
  //fprintf(stderr, "  expand_tilde => \"%s\"\n", ret.string_of());
  if (exists_executable(ret)) return ret;
  
  // TODO: any other way to find executable?
  // no procfs info available (argv, cwd, env) so we're stuck
  return "";
}



// HERE BE DRAGONS



// TODO: this is a lousy implementation
#ifdef BPATCH_LIBRARY
bool process::dumpImage(string outFile) {
#else
bool process::dumpImage() {
  char buf[512];
  sprintf(buf, "image.%d", pid);
  string outFile = buf;
#endif
  //fprintf(stderr, "!!! process::dumpImage(%s)\n", outFile.string_of());
  
  // copy and open file
  image *img = getImage();
  string imgFile = img->file();
  char buf1[1024];
  sprintf(buf1, "cp %s %s", imgFile.string_of(), outFile.string_of());
  system(buf1);
  int fd = open(outFile.string_of(), O_RDWR, 0);
  if (fd < 0) return false;

  // overwrite ".text" section with runtime contents

  bool is_elf64 = img->getObject().is_elf64();
  Elf *elfp = elf_begin(fd, ELF_C_READ, 0);
  assert(elfp);
  int e_shstrndx;
  if (is_elf64) {

    Elf64_Ehdr *ehdrp = elf64_getehdr(elfp);
    assert(ehdrp);
    e_shstrndx = ehdrp->e_shstrndx;

  } else { // 32-bit

    Elf32_Ehdr *ehdrp = elf32_getehdr(elfp);
    assert(ehdrp);
    e_shstrndx = ehdrp->e_shstrndx;

  }
  Elf_Scn *shstrscnp = elf_getscn(elfp, e_shstrndx);
  assert(shstrscnp);
  Elf_Data *shstrdatap = elf_getdata(shstrscnp, 0);
  assert(shstrdatap);
  char *shnames = (char *)shstrdatap->d_buf;

  Address txtAddr = 0;
  int txtLen = 0;
  int txtOff = 0;
  Elf_Scn *scn = 0;
  while ((scn = elf_nextscn(elfp, scn)) != 0) {
    pdElfShdr pd_shdr(scn, is_elf64);
    char *name = (char *)&shnames[pd_shdr.pd_name];
    if (strcmp(name, ".text") == 0) {
      txtOff = pd_shdr.pd_offset;
      txtLen = pd_shdr.pd_size;
      txtAddr = pd_shdr.pd_addr;
      break;
    }
  }
   
  if (txtLen > 0) {
    char *buf2 = new char[txtLen];
    // TODO: readTextSpace_() only defined for BPATCH_MUTATIONS_ACTIVE
    if (!(readDataSpace_((void *)txtAddr, txtLen, buf2))) {
      delete [] buf2;
      return false;
    }
    lseek(fd, txtOff, SEEK_SET);
    write(fd, buf2, txtLen);
    close(fd);
    delete [] buf2;
  }
  
  return true;
}

// getActiveFrame(): populate Frame object using toplevel frame
void Frame::getActiveFrame(process *p)
{
  gregset_t regs;
  int proc_fd = p->getProcFileDescriptor();
  if (ioctl(proc_fd, PIOCGREG, &regs) == -1) {
    perror("Frame::Frame(PIOCGREG)");
    return;
  }
  
  pc_ = regs[PROC_REG_PC];
  sp_ = regs[PROC_REG_SP];
  fp_ = regs[PROC_REG_FP];
  
  // sometimes the actual $fp is zero
  // (kludge for stack walk code)
  if (fp_ == 0) fp_ = sp_;
}
 
// determine if the basetramp frame is active
// NOTE: arguments 2-4 are from findAddressInFuncsAndTramps()
// NOTE: if "ip" is non-NULL, one of "bt" and "mt" must also be non-NULL
static bool instrFrameActive(Address pc,
			     instPoint *ip, 
			     trampTemplate *bt, 
			     instInstance *mt)
{
  // "ip" is set if $pc in instrumentation code
  // the basetramp frame is never active in native code
  if (!ip) return false;

  // "bt" is set if $pc is in basetramp
  // the basetramp frame is active in parts of the basetramp
  if (bt) return bt->inSavedRegion(pc);

  // "mt" is set if $pc is in minitramp
  // the basetramp frame is always active in minitramps
  else if (mt) return true;

  // one of "bt" and "mt" must be non-NULL
  assert(0);
  return false;
}

/* nativeFrameActive(): determine if the (relative) $pc is between the
   stack frame save and restore insns */
/* TODO: To handle functions with multiple exit points (and restores),
   the $pc should be considered "after" a given insn only if the $pc
   is within some proximity.  This heuristic is a poor imitation of
   dataflow analysis. */
#define STACK_RESTORE_PROXIMITY (4*INSN_SIZE)
static bool nativFrameActive(Address pc_off, pd_Function *callee)
{
  if (callee->frame_size == 0) return false;

  if (pc_off > callee->sp_mod) {
    int nret = callee->sp_ret.size();
    Address last_ret = callee->sp_ret[nret-1];
    if (pc_off <= last_ret) return true;
  }

  return false;
}

// constants derived from "tramp-mips.s" (must remain consistent)
// size of basetramp stack frame
static const int bt_frame_size = 512;
// offset of save insns from basetramp "daddiu sp,sp,-512"
static const int bt_ra_save_off = (64 * INSN_SIZE); 
static const int bt_fp_save_off = (63 * INSN_SIZE); 
// basetramp stack frame slots
static const int bt_ra_slot = -512;
static const int bt_fp_slot = -504;

static bool basetrampRegSaved(Address pc, Register reg,
			      instPoint *ip,
			      trampTemplate *bt,
			      instInstance *mt)
{
  if (!ip) return false;
  if (mt) return true;
  assert(bt);

  Address save_off;
  switch(reg) {
  case REG_RA:
    save_off = bt_ra_save_off;
    break;
  case REG_S8:
    save_off = bt_fp_save_off;
    break;
  default:
    assert(0);
  }

  if (pc >  bt->baseAddr + bt->savePreInsOffset + save_off && 
      pc <= bt->baseAddr + bt->restorePreInsOffset) {
    return true;
  }
  if (pc >  bt->baseAddr + bt->savePostInsOffset + save_off && 
      pc <= bt->baseAddr + bt->restorePostInsOffset) {
    return true;
  }

  return false;
}

// return the corresponding $pc in native code
// (for a $pc in instrumentation code)
static Address adjustedPC(Address pc, Address fn_addr,
			  instPoint *ip,
			  trampTemplate *bt,
			  instInstance *mt)
{
  // if $pc in native code, no adjustment necessary
  if (!ip) return pc;
  
  // runtime address of instrumentation point
  Address pt_addr = fn_addr + ip->offset();

  if (bt) {
    // $pc in basetramp
    assert(bt->inBasetramp(pc));
    // assumption: basetramp has exactly two displaced insns
    assert(bt->skipPostInsOffset == bt->emulateInsOffset + 2*INSN_SIZE);

    int bt_off = pc - bt->baseAddr;
    if (bt_off <= bt->emulateInsOffset) {
      // $pc is at or before first displaced insn
      // $pc' = address of instr pt
      return pt_addr;
    } else if (bt_off == bt->emulateInsOffset + INSN_SIZE) {
      // $pc is at second displaced insn (delay slot)
      // $pc' = address of instr pt delay slot
      return pt_addr + INSN_SIZE;
    } else if (bt_off > bt->emulateInsOffset + INSN_SIZE) {
      // $pc is after second displaced insn
      // $pc' = address of insn after instr pt
      return pt_addr + (2*INSN_SIZE);
    }
  }

  else if (mt) {
    // $pc in minitramp
    if (mt->when == callPreInsn) {
      // $pc in pre-insn instr
      // $pc' = address of instr pt
      return pt_addr;
    } else if (mt->when == callPostInsn) {
      // $pc in post-insn instr
      // $pc' = address of insn after instr pt
      return pt_addr + (2*INSN_SIZE);
    }
  }

  // should not be reached: error
  assert(0);
  return pc;
}

// TODO: need dataflow, ($pc < saveInsn) insufficient
Frame Frame::getCallerFrameNormal(process *p) const
{
  // check for active instrumentation
  // (i.e. $pc in native/basetramp/minitramp code)
  instPoint     *ip = NULL;
  trampTemplate *bt = NULL;
  instInstance  *mt = NULL;
  pd_Function *callee = findAddressInFuncsAndTramps(p, pc_, ip, bt, mt);
  // non-NULL "ip" means that $pc is in instrumentation
  // non-NULL "bt" means that $pc is in basetramp
  // non-NULL "mt" means that $pc is in minitramp
  if (ip) assert(bt || mt);

  // calculate runtime address of callee fn
  if (!callee) {
    fprintf(stderr, "!!! <0x%016lx:???> unknown callee\n", pc_);
    return Frame(); // zero frame
  }
  Address base_addr;
  p->getBaseAddress(callee->file()->exec(), base_addr);
  Address fn_addr = base_addr + callee->getAddress(0);
  
  /* 
  // debug
  if (uppermost_) {
    char *info = "";
    if (ip) info = (bt) ? ("[basetramp]") : ("[minitramp]");
    fprintf(stderr, ">>> toplevel frame => \"%s\" %s\n",
	    callee->prettyName().string_of(), info);
  }
  */

  // adjust $pc for active instrumentation 
  Address pc_adj = adjustedPC(pc_, fn_addr, ip, bt, mt);
  // $pc' (adjusted $pc) should be inside callee
  /*
  if (pc_adj < fn_addr || pc_adj >= fn_addr + callee->size()) {
    fprintf(stderr, "!!! adjusted $pc\n");
    fprintf(stderr, "    0x%016lx $pc\n", pc_);
    fprintf(stderr, "    0x%016lx adjusted $pc\n", pc_adj);
    fprintf(stderr, "    0x%016lx fn start\n", fn_addr);
    fprintf(stderr, "    0x%016lx fn end\n", fn_addr + callee->size());
  }
  assert(pc_adj >= fn_addr && pc_adj < fn_addr + callee->size());
  */

  // which frames (native/basetramp) are active?
  Address pc_off = pc_adj - fn_addr;
  bool nativeFrameActive = nativFrameActive(pc_off, callee);
  bool basetrampFrameActive = instrFrameActive(pc_, ip, bt, mt);

  // frame pointers for native and basetramp frames
  Address fp_bt = sp_;
  if (basetrampFrameActive) {
    fp_bt += bt_frame_size;
  }
  Address fp_native = fp_bt;
  if (nativeFrameActive) {
    fp_native += callee->frame_size;
  }
  // override calculated $fp if frame pointer conventions used
  if (callee->uses_fp) fp_native = fp_;

  // which frames is $ra saved in?
  pd_Function::regSave_t &ra_save = callee->reg_saves[REG_RA];
  bool ra_saved_native = (ra_save.slot != -1 && pc_off > ra_save.insn);
  bool ra_saved_bt = basetrampRegSaved(pc_, REG_RA, ip, bt, mt);

  // which frames is $fp saved in?
  pd_Function::regSave_t &fp_save = callee->reg_saves[REG_S8];
  bool fp_saved_native = (fp_save.slot != -1 && pc_off > fp_save.insn);
  bool fp_saved_bt = basetrampRegSaved(pc_, REG_S8, ip, bt, mt);

  // sanity checks
  if (!uppermost_) {
    /* if this is a non-toplevel stack frame, the basetramp $pc must
       point to just after an emulated call insn */
    if (bt) {
      assert(bt->skipPostInsOffset == bt->emulateInsOffset + (2*INSN_SIZE));
      /*
      if (pc_ != bt->baseAddr + bt->skipPostInsOffset) {
	fprintf(stderr, "!!! emulated call\n");
	fprintf(stderr, "    0x%016lx $pc\n", pc_);
	fprintf(stderr, "    0x%016lx emulated\n", bt->baseAddr + bt->skipPostInsOffset);
      }
      assert(pc_ == bt->baseAddr + bt->skipPostInsOffset);
      */
    }
    // non-toplevel basetramp frames should always be fully saved
    if (basetrampFrameActive) {
      /*
      if (!fp_saved_bt || !ra_saved_bt) {
	fprintf(stderr, "!!! $fp or $ra not saved in basetramp frame\n");
	fprintf(stderr, "    0x%016lx $pc\n", pc_);
	if (bt) { 
	  fprintf(stderr, "     [in basetramp]\n");
	  fprintf(stderr, "     0x%016lx basetramp\n", bt->baseAddr);
	} else if (mt) { fprintf(stderr, "     [in minitramp]\n"); }
      }
      assert(fp_saved_bt && ra_saved_bt);
      */
    }
  }

  // find caller $pc (callee $ra)
  Address ra;
  Address ra_addr = 0;
  char ra_debug[256];
  sprintf(ra_debug, "<unknown>");
  if (nativeFrameActive && ra_saved_native) {
    // $ra saved in native frame
    ra_addr = fp_native + ra_save.slot;
    ra = readAddressInMemory(p, ra_addr, ra_save.dword);
    sprintf(ra_debug, "[$fp - %i]", -ra_save.slot);
  } else if (basetrampFrameActive && ra_saved_bt) {
    // $ra saved in basetramp frame
    ra_addr = fp_bt + bt_ra_slot;
    ra = readAddressInMemory(p, ra_addr, true);
    sprintf(ra_debug, "[$fp - %i]", -bt_ra_slot);
  } else {
    // $ra not saved in any frame
    // try to read $ra from registers (toplevel only)
    if (uppermost_) {
      // $ra in live register
      gregset_t regs;
      int proc_fd = p->getProcFileDescriptor();
      if (ioctl(proc_fd, PIOCGREG, &regs) == -1) {
	perror("process::readDataFromFrame(PIOCGREG)");
	return Frame(); // zero frame
      }
      ra = regs[PROC_REG_RA];
      sprintf(ra_debug, "regs[ra]");
    } else {
      /*
      // debug
      if (callee->prettyName() != "main" &&
	  callee->prettyName() != "__start")
	fprintf(stderr, "!!! <0x%016lx:\"%s\"> $ra not saved\n",
		pc_adj, callee->prettyName().string_of());
      */
      // $ra cannot be found (error)
      return Frame(); // zero frame
    }
  }

  // find caller $fp
  Address fp2;
  Address fp_addr = 0;
  char fp_debug[256];
  sprintf(fp_debug, "<unknown>");
  if (nativeFrameActive && fp_saved_native) {
    // $fp saved in native frame
    fp_addr = fp_native + fp_save.slot;
    fp2 = readAddressInMemory(p, fp_addr, fp_save.dword);
    sprintf(fp_debug, "[$fp - %i]", -fp_save.slot);
  } else if (basetrampFrameActive && fp_saved_bt) {
    // $ra saved in basetramp frame
    fp_addr = fp_bt + bt_fp_slot;
    fp2 = readAddressInMemory(p, fp_addr, true);
    sprintf(fp_debug, "[$fp - %i]", -bt_fp_slot);
  } else {
    // $fp not saved in any frame
    // pass up callee $fp
    fp2 = fp_;
    sprintf(fp_debug, "(callee $fp)");
  }
  // sometimes the retrieved $fp is zero
  // (kludge for stack walk code)
  if (fp2 == 0) fp2 = fp_;

  // determine location of caller $pc (native code, basetramp, minitramp)
  instPoint *ip2 = NULL;
  trampTemplate *bt2 = NULL;
  instInstance *mt2 = NULL;
  pd_Function *caller = findAddressInFuncsAndTramps(p, ra, ip2, bt2, mt2);

  /* 
  // debug
  if(!caller) {
    fprintf(stderr, "!!! 0x%016lx unknown caller (callee:\"%s\")\n",
	    ra, callee->prettyName().string_of());    
    const image *owner = callee->file()->exec();
    Address obj_base = 0;
    p->getBaseAddress(owner, obj_base);
    Address addr;
    // frame pointer conventions
    if (callee->uses_fp) {
      fprintf(stderr, "    uses frame pointer\n");
      addr = obj_base + callee->getAddress(0) + callee->fp_mod;
      disDataSpace(p, (void *)addr, 1, "    $fp frame ");
      addr = obj_base + callee->getAddress(0) + ra_save.insn;
      disDataSpace(p, (void *)addr, 1, "    $ra save  ");
    } else {
      fprintf(stderr, "    no frame pointer\n");
      addr = obj_base + callee->getAddress(0) + callee->sp_mod;
      disDataSpace(p, (void *)addr, 1, "    $sp frame ");
      addr = obj_base + callee->getAddress(0) + ra_save.insn;
      disDataSpace(p, (void *)addr, 1, "    $ra save  ");
    }
    // callee $pc
    if (!ip) { 
      fprintf(stderr, "    in native code\n");
    } else if (bt) {
      fprintf(stderr, "    in basetramp\n");
    } else if (mt) {
      fprintf(stderr, "    in minitramp\n");    
    }
    fprintf(stderr, "    0x%016lx $pc\n", pc_);
    fprintf(stderr, "    0x%016lx native $pc\n", pc_adj);
    fprintf(stderr, "    %18s callee\n", callee->prettyName().string_of());
    // stack frames
    fprintf(stderr, "    0x%016lx callee $sp\n", sp_);
    fprintf(stderr, "    0x%016lx callee $fp\n", fp_);
    if (basetrampFrameActive) {
      fprintf(stderr, "    basetramp frame active\n");
      fprintf(stderr, "    0x%016x basetramp framesize\n", bt_frame_size);
      fprintf(stderr, "    0x%016lx basetramp $fp\n", fp_bt);
    } else fprintf(stderr, "    basetramp frame not active\n");
    if (nativeFrameActive) {
      fprintf(stderr, "    native frame active\n");
      fprintf(stderr, "    0x%016x native framesize\n", callee->frame_size);
      fprintf(stderr, "    0x%016lx native $fp\n", fp_native);
    } else fprintf(stderr, "    native frame not active\n");
    fprintf(stderr, "    0x%016lx $fp\n", fp_native);
    // caller $pc
    fprintf(stderr, "    %18s $ra slot\n", ra_debug);
    fprintf(stderr, "    0x%016lx $ra location\n", ra_addr);
    fprintf(stderr, "    0x%016lx $ra\n", ra);    
    // caller $fp
    fprintf(stderr, "    %18s $fp slot\n", fp_debug);
    fprintf(stderr, "    0x%016lx $fp location\n", fp_addr);
    fprintf(stderr, "    0x%016lx caller $fp\n", fp2);    
  }
  */

  // caller frame is invalid if $pc does not resolve to a function
  if (!caller) return Frame(); // zero frame

  // return value
  Frame ret;
  ret.pc_ = ra;
  ret.sp_ = fp_native;
  ret.fp_ = fp2;

  /* 
  // debug
  fprintf(stderr, "    frame $ra(0x%016lx) $sp(0x%016lx) $fp(0x%016lx)", 
	  ret.pc_, ret.sp_, ret.fp_);
  char *info2 = "";
  if (ip2) info2 = (bt2) ? ("[basetramp]") : ("[minitramp]");
  fprintf(stderr, " => \"%s\" %s\n", caller->prettyName().string_of(), info2);
  */

  return ret;
}

// TODO: implement
// do leaf functions exist on Irix (other than syscalls)?
bool process::needToAddALeafFrame(Frame f, Address &leaf_pc) {
  return false;
}


//
// paradynd-only methods
//


void OS::osDisconnect(void) {
  //fprintf(stderr, ">>> osDisconnect()\n");
  int fd = open("/dev/tty", O_RDONLY);
  ioctl(fd, TIOCNOTTY, NULL); 
  P_close(fd);
}

#ifdef SHM_SAMPLING
// returns user+sys time from the u or proc area of the inferior process, which in
// turn is presumably obtained by mmapping it (sunos) or by using a /proc ioctl
// to obtain it (solaris).  It must not stop the inferior process in order
// to obtain the result, nor can it assue that the inferior has been stopped.
// The result MUST be "in sync" with rtinst's DYNINSTgetCPUtime().
// TODO: "#ifdef PURE_BUILD" support
time64 process::getInferiorProcessCPUtime(int /*lwp_id*/)
{
  //fprintf(stderr, ">>> getInferiorProcessCPUtime()\n");
  time64 ret;

  /*
  pracinfo_t t;
  ioctl(proc_fd, PIOCACINFO, &t);
  ret = PDYN_div1000(t.pr_timers.ac_utime + t.pr_timers.ac_stime);
  */

  timespec_t t[MAX_PROCTIMER];
  if (ioctl(proc_fd, PIOCGETPTIMER, t) == -1) {
    //perror("getInferiorProcessCPUtime - PIOCGETPTIMER");
    return previous;
  }
  ret = 0;
  ret += PDYN_mulMillion(t[AS_USR_RUN].tv_sec); // sec to usec  (user)
  ret += PDYN_mulMillion(t[AS_SYS_RUN].tv_sec); // sec to usec  (sys)
  ret += PDYN_div1000(t[AS_USR_RUN].tv_nsec);   // nsec to usec (user)
  ret += PDYN_div1000(t[AS_SYS_RUN].tv_nsec);   // nsec to usec (sys)

  // sanity check: time should not go backwards
  if (ret < previous) {
    logLine("*** time going backwards in paradynd ***\n");
    ret = previous;
  }
  previous = ret;

  return ret;
}
#endif

