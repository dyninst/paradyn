// $Id: TermWinTkGUI.C,v 1.1 2004/06/21 18:59:04 pcroth Exp $

#include <stdio.h>

#include "tcl.h"
#include "tk.h"

#include "common/h/headers.h"
#include "paradyn/src/UIthread/pdLogo.h"
#include "paradyn/xbm/logo.xbm"

#include "visiClients/termWin/src/TermWinTkGUI.h"



extern int initialize_tcl_sources(Tcl_Interp *);


TermWinTkGUI::TermWinTkGUI( pdstring _progName,
                            PDSOCKET _lsock,
                            PDSOCKET _stdin_sock )
  : TermWin( _lsock, _stdin_sock ),
    interp( NULL ),
    progName( _progName ),
    closeMode( CloseModeCloseOnParadynExit ),
    tkTid( THR_TID_UNSPEC )
{
    // nothing else to do
}


TermWinTkGUI::~TermWinTkGUI( void )
{
    // release our interpreter
    if( interp != NULL )
    {
        Tcl_DeleteCommand( interp, "closeMode" );

        Tcl_DeleteInterp( interp );
        interp = NULL;
    }
}


bool
TermWinTkGUI::Init( void )
{
    // initialize base class
    if( !TermWin::Init() )
    {
        return false;
    }

    // Let Tcl know something about our executable (and do some filesystem-
    // specific initialization).
    //
    // NOTE: this is obligatory with modern versions of Tcl.
    Tcl_FindExecutable( progName.c_str() );

    // ensure we have an interpreter
    assert( interp == NULL );
    interp = Tcl_CreateInterp();

    // initialize Tcl
    if( Tcl_Init( interp ) != TCL_OK )
    {
        ShowError( "TermWin: failed to initialize Tcl interpreter" );
        return false;
    }

    // Set argv0 before we do any other Tk program initialization because
    // Tk takes the main window's class and instance name from argv0
    // We set it to "paradyn" instead of "termwin" so that we can 
    // set resources for all paradyn-related windows with the same root.
    Tcl_SetVar( interp,
                "argv0", 
                "paradyn",
                TCL_GLOBAL_ONLY );

    // initialize Tk
    if( Tk_Init( interp ) != TCL_OK )
    {
        ShowError( "TermWin: failed to initialize Tk" );
        return false;
    }

    // register our command for setting the close mode
    Tcl_CreateCommand( interp, "closeMode", CloseModeCmd, this, NULL );

    // register command for drawing Paradyn logo
    pdLogo::install_fixed_logo("paradynLogo", logo_bits,
                                logo_width, logo_height);

    tcl_cmd_installer createPdLogo( interp,
                                    "makeLogo",
                                    pdLogo::makeLogoCommand,
                                    (ClientData)Tk_MainWindow( interp ) );

    // eval the Tcl sources generated by tcl2c
    if( initialize_tcl_sources( interp ) != TCL_OK )
    {
        ShowError( "failed to evaluate Tcl source" );
        return false;
    }

    return true;
}



bool
TermWinTkGUI::IsDoneHandlingEvents( void ) const
{
    if( TermWin::IsDoneHandlingEvents() )
    {
        return true;
    }
    return (Tk_GetNumMainWindows() == 0);
}




bool
TermWinTkGUI::DispatchEvent( thread_t mtid, tag_t mtag )
{
    return TermWin::DispatchEvent( mtid, mtag );
}



int
TermWinTkGUI::CloseModeCmd( ClientData cd, Tcl_Interp* /* interp */,
                                int argc, TCLCONST char** argv )
{
    int ret = TCL_OK;


    TermWinTkGUI* tkg = (TermWinTkGUI*)cd;
    if( tkg == NULL )
    {
        return TCL_ERROR;
    }

    assert(argc == 2);
    const int mode = atoi(argv[1]);

    if( mode == CloseModeCloseOnParadynExit )
    {
        tkg->SetCloseMode( CloseModeCloseOnParadynExit );
    }
    else if( mode == CloseModePersistent )
    {
        tkg->SetCloseMode( CloseModePersistent );
    }
    else
    {
        ret = TCL_ERROR;
    }
    return ret;
}


void 
TermWinTkGUI::Print( char* buf, int num, bool isFromDaemon )
{
    if (num <= 0)
    {
        return;
    }

    char command[2048];
    sprintf( command, ".termwin.textarea.text insert end {%.*s} %s",
            num, buf,
            (isFromDaemon ? "paradyn_tag" : "app_tag") );
    Tcl_Eval( interp, command );

    sprintf( command, ".termwin.textarea.text yview -pickplace end" );
    Tcl_Eval( interp, command );
}


void
TermWinTkGUI::shutdown( void )
{
    // if we aren't supposed to be persistent, indicate we should 
    // shut down gracefully at the earliest opportunity
    if( closeMode != CloseModePersistent )
    {
        SetShouldExitFlag();
    }
}


void
TermWinTkGUI::ShowError( const char* msg )
{
#if READY
    if( we have initialized Tk )
    {
        display the error message in a Tk dialog
    }
    else
    {
        fprintf( stderr, "TermWin: %s", msg );
    }
#else
    fprintf( stderr, "TermWin: %s", msg );
#endif // READY
}


bool
TermWinTkGUI::DoPendingWork( void )
{
    // We use Tk_DoOneEvent (w/o blocking) to soak up and process
    // pending Tk events, if any.  Returns as soon as there are no
    // Tk events to process.
    // NOTE: Tk_DoOneEvent normally returns 1 to indicate one event
    // was handled.
    // NOTE: This includes (as it should) Tk idle events.
    // NOTE: This is basically the same as Tcl_Eval(interp, "update"), but
    //       who wants to incur the expense of tcl parsing?
    while( Tk_DoOneEvent(TK_DONT_WAIT) == 1 )
    {
        // nothing else to do
    }

    return true;
}


